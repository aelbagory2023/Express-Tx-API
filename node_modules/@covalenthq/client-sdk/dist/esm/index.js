var version = "2.1.1";

const bigIntParser = (val) => {
    if (val === null || val === undefined) {
        return null;
    }
    return BigInt(val);
};

const baseUrl = "https://api.covalenthq.com/v1";
const endpointGenerator = (extension = "", params = []) => {
    extension = extension.replace(baseUrl, "");
    if (extension.startsWith("/")) {
        extension = extension.slice(1);
    }
    if (!extension.endsWith("/")) {
        extension = `${extension}/`;
    }
    const urlParams = new URLSearchParams();
    params.forEach((param) => {
        if (param.value !== undefined && param.value !== null) {
            urlParams.append(param.key, param.value.toString());
        }
    });
    return new URL(`${baseUrl}/${extension}?${urlParams}`);
};

async function* paginateEndpoint(endpoint, execution, parseData, implementation) {
    let _endpoint = new URL(endpoint);
    let hasMore = true;
    let page_number = +(_endpoint.searchParams.get("page-number") ?? 0);
    while (hasMore) {
        try {
            if (implementation === "pagination") {
                _endpoint.searchParams.set("page-number", page_number.toString());
                const parsedData = await execution.execute(_endpoint, parseData);
                if (parsedData.error) {
                    throw parsedData;
                }
                if (!parsedData.data?.pagination?.has_more) {
                    hasMore = false;
                }
                else {
                    page_number++;
                }
                yield parsedData;
            }
            else if (implementation === "links") {
                const parsedData = await execution.execute(_endpoint, parseData);
                const prevLink = parsedData.data?.links?.prev || null;
                if (!prevLink) {
                    hasMore = false;
                }
                else {
                    _endpoint = new URL(`${prevLink}?${_endpoint.searchParams}`);
                }
                yield parsedData;
            }
        }
        catch (error) {
            hasMore = false;
            yield {
                data: null,
                error: true,
                error_code: error?.cause?.code || error?.error_code || 500,
                error_message: error?.cause?.message ||
                    error?.error_message ||
                    "Internal server error",
            };
        }
    }
}

/**
 * Balances APIs
 *
 */
class BalanceService {
    constructor(execution) {
        this.execution = execution;
    }
    /**
     *
     * Commonly used to fetch the native, fungible (ERC20), and non-fungible (ERC721 & ERC1155) tokens held by an address. Response includes spot prices and other metadata.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTokenBalancesForWalletAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `nft`: If `true`, NFTs will be included in the response.
     *   - `noNftFetch`: If `true`, only NFTs that have been cached will be included in the response. Helpful for faster response times.
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *   - `noNftAssetMetadata`: If `true`, the response shape is limited to a list of collections and token ids, omitting metadata and asset information. Helpful for faster response times and wallets holding a large number of NFTs.
     *
     */
    async getTokenBalancesForWalletAddress(chainName, walletAddress, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/address/${walletAddress}/balances_v2`, [
            {
                key: "quote-currency",
                value: queryParamOpts?.quoteCurrency,
            },
            {
                key: "nft",
                value: queryParamOpts?.nft,
            },
            {
                key: "no-nft-fetch",
                value: queryParamOpts?.noNftFetch,
            },
            {
                key: "no-spam",
                value: queryParamOpts?.noSpam,
            },
            {
                key: "no-nft-asset-metadata",
                value: queryParamOpts?.noNftAssetMetadata,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((balanceItem) => ({
                        ...balanceItem,
                        balance: bigIntParser(balanceItem.balance),
                        balance_24h: bigIntParser(balanceItem.balance_24h),
                        last_transferred_at: balanceItem.last_transferred_at
                            ? new Date(balanceItem.last_transferred_at)
                            : null,
                        nft_data: balanceItem.nft_data
                            ? balanceItem.nft_data.map((nftItem) => ({
                                ...nftItem,
                                token_id: bigIntParser(nftItem.token_id),
                                token_balance: bigIntParser(nftItem.token_balance),
                                token_price_wei: bigIntParser(nftItem.token_price_wei),
                            }))
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to render a daily portfolio balance for an address broken down by the token. The timeframe is user-configurable, defaults to 30 days.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetHistoricalPortfolioForWalletAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `days`: The number of days to return data for. Defaults to 30 days.
     *
     */
    async getHistoricalPortfolioForWalletAddress(chainName, walletAddress, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/address/${walletAddress}/portfolio_v2`, [
            {
                key: "quote-currency",
                value: queryParamOpts?.quoteCurrency,
            },
            {
                key: "days",
                value: queryParamOpts?.days,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items =
                    data.data.items?.map((portfolioItem) => ({
                        ...portfolioItem,
                        holdings: portfolioItem.holdings?.map((holdingItem) => ({
                            ...holdingItem,
                            timestamp: holdingItem.timestamp && data.data?.updated_at
                                ? new Date(data.data.updated_at)
                                : null,
                            close: {
                                ...holdingItem.close,
                                balance: bigIntParser(holdingItem.close?.balance),
                            },
                            high: {
                                ...holdingItem.high,
                                balance: bigIntParser(holdingItem.high?.balance),
                            },
                            low: {
                                ...holdingItem.low,
                                balance: bigIntParser(holdingItem.low?.balance),
                            },
                            open: {
                                ...holdingItem.open,
                                balance: bigIntParser(holdingItem.open?.balance),
                            },
                        })) || null,
                    })) || null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to render the transfer-in and transfer-out of a token along with historical prices from an address.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetErc20TransfersForWalletAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `contractAddress`: The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *   - `startingBlock`: The block height to start from, defaults to `0`.
     *   - `endingBlock`: The block height to end at, defaults to current block height.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async *getErc20TransfersForWalletAddress(chainName, walletAddress, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/address/${walletAddress}/transfers_v2`, [
            {
                key: "quote-currency",
                value: queryParamOpts?.quoteCurrency,
            },
            {
                key: "contract-address",
                value: queryParamOpts?.contractAddress,
            },
            {
                key: "starting-block",
                value: queryParamOpts?.startingBlock,
            },
            {
                key: "ending-block",
                value: queryParamOpts?.endingBlock,
            },
            {
                key: "page-size",
                value: queryParamOpts?.pageSize,
            },
            {
                key: "page-number",
                value: queryParamOpts?.pageNumber,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((ercItem) => ({
                        ...ercItem,
                        block_signed_at: ercItem.block_signed_at
                            ? new Date(ercItem.block_signed_at)
                            : null,
                        value: bigIntParser(ercItem.value),
                        fees_paid: bigIntParser(ercItem.fees_paid),
                        transfers: ercItem.transfers
                            ? ercItem.transfers.map((transferItem) => ({
                                ...transferItem,
                                balance: bigIntParser(transferItem.balance),
                                block_signed_at: transferItem.block_signed_at
                                    ? new Date(transferItem.block_signed_at)
                                    : null,
                                delta: bigIntParser(transferItem.delta),
                            }))
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        for await (const data of paginateEndpoint(endpoint, this.execution, parseData, "pagination")) {
            yield data;
        }
    }
    /**
     *
     * Commonly used to render the transfer-in and transfer-out of a token along with historical prices from an address.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetErc20TransfersForWalletAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `contractAddress`: The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *   - `startingBlock`: The block height to start from, defaults to `0`.
     *   - `endingBlock`: The block height to end at, defaults to current block height.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getErc20TransfersForWalletAddressByPage(chainName, walletAddress, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/address/${walletAddress}/transfers_v2`, [
            {
                key: "quote-currency",
                value: queryParamOpts?.quoteCurrency,
            },
            {
                key: "contract-address",
                value: queryParamOpts?.contractAddress,
            },
            {
                key: "starting-block",
                value: queryParamOpts?.startingBlock,
            },
            {
                key: "ending-block",
                value: queryParamOpts?.endingBlock,
            },
            {
                key: "page-size",
                value: queryParamOpts?.pageSize,
            },
            {
                key: "page-number",
                value: queryParamOpts?.pageNumber,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((blockTxItem) => ({
                        ...blockTxItem,
                        block_signed_at: blockTxItem.block_signed_at
                            ? new Date(blockTxItem.block_signed_at)
                            : null,
                        fees_paid: bigIntParser(blockTxItem.fees_paid),
                        transfers: blockTxItem.transfers?.map((transferItem) => ({
                            ...transferItem,
                            balance: bigIntParser(transferItem.balance),
                            block_signed_at: transferItem.block_signed_at
                                ? new Date(transferItem.block_signed_at)
                                : null,
                            delta: bigIntParser(transferItem.delta),
                        })) || null,
                        value: bigIntParser(blockTxItem.value),
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to get a list of all the token holders for a specified ERC20 or ERC721 token. Returns historic token holders when block-height is set (defaults to `latest`). Useful for building pie charts of token holders.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} tokenAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTokenHoldersV2ForTokenAddressQueryParamOpts} queryParamOpts
     *   - `blockHeight`: Ending block to define a block range. Omitting this parameter defaults to the latest block height.
     *   - `pageSize`: Number of items per page. Note: Currently, only values of `100` and `1000` are supported. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `date`: Ending date to define a block range (YYYY-MM-DD). Omitting this parameter defaults to the current date.
     *
     */
    async *getTokenHoldersV2ForTokenAddress(chainName, tokenAddress, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/tokens/${tokenAddress}/token_holders_v2`, [
            {
                key: "block-height",
                value: queryParamOpts?.blockHeight,
            },
            {
                key: "page-size",
                value: queryParamOpts?.pageSize,
            },
            {
                key: "page-number",
                value: queryParamOpts?.pageNumber,
            },
            {
                key: "date",
                value: queryParamOpts?.date,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((tokenItem) => ({
                        ...tokenItem,
                        balance: bigIntParser(tokenItem.balance),
                        total_supply: bigIntParser(tokenItem.total_supply),
                    }))
                    : null;
            }
            return data;
        };
        for await (const data of paginateEndpoint(endpoint, this.execution, parseData, "pagination")) {
            yield data;
        }
    }
    /**
     *
     * Commonly used to get a list of all the token holders for a specified ERC20 or ERC721 token. Returns historic token holders when block-height is set (defaults to `latest`). Useful for building pie charts of token holders.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} tokenAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTokenHoldersV2ForTokenAddressQueryParamOpts} queryParamOpts
     *   - `blockHeight`: Ending block to define a block range. Omitting this parameter defaults to the latest block height.
     *   - `pageSize`: Number of items per page. Note: Currently, only values of `100` and `1000` are supported. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `date`: Ending date to define a block range (YYYY-MM-DD). Omitting this parameter defaults to the current date.
     *
     */
    async getTokenHoldersV2ForTokenAddressByPage(chainName, tokenAddress, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/tokens/${tokenAddress}/token_holders_v2`, [
            {
                key: "block-height",
                value: queryParamOpts?.blockHeight,
            },
            {
                key: "page-size",
                value: queryParamOpts?.pageSize,
            },
            {
                key: "page-number",
                value: queryParamOpts?.pageNumber,
            },
            {
                key: "date",
                value: queryParamOpts?.date,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((balanceItem) => ({
                        ...balanceItem,
                        balance: bigIntParser(balanceItem.balance),
                        total_supply: bigIntParser(balanceItem.total_supply),
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to fetch the historical native, fungible (ERC20), and non-fungible (ERC721 & ERC1155) tokens held by an address at a given block height or date. Response includes daily prices and other metadata.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetHistoricalTokenBalancesForWalletAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `nft`: If `true`, NFTs will be included in the response.
     *   - `noNftFetch`: If `true`, only NFTs that have been cached will be included in the response. Helpful for faster response times.
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *   - `noNftAssetMetadata`: If `true`, the response shape is limited to a list of collections and token ids, omitting metadata and asset information. Helpful for faster response times and wallets holding a large number of NFTs.
     *   - `blockHeight`: Ending block to define a block range. Omitting this parameter defaults to the latest block height.
     *   - `date`: Ending date to define a block range (YYYY-MM-DD). Omitting this parameter defaults to the current date.
     *
     */
    async getHistoricalTokenBalancesForWalletAddress(chainName, walletAddress, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/address/${walletAddress}/historical_balances`, [
            {
                key: "quote-currency",
                value: queryParamOpts?.quoteCurrency,
            },
            {
                key: "nft",
                value: queryParamOpts?.nft,
            },
            {
                key: "no-nft-fetch",
                value: queryParamOpts?.noNftFetch,
            },
            {
                key: "no-spam",
                value: queryParamOpts?.noSpam,
            },
            {
                key: "no-nft-asset-metadata",
                value: queryParamOpts?.noNftAssetMetadata,
            },
            {
                key: "block-height",
                value: queryParamOpts?.blockHeight,
            },
            {
                key: "date",
                value: queryParamOpts?.date,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((balanceItem) => ({
                        ...balanceItem,
                        balance: bigIntParser(balanceItem.balance),
                        last_transferred_at: balanceItem.last_transferred_at
                            ? new Date(balanceItem.last_transferred_at)
                            : null,
                        nft_data: balanceItem.nft_data
                            ? balanceItem.nft_data.map((nftItem) => ({
                                ...nftItem,
                                token_id: bigIntParser(nftItem.token_id),
                                token_balance: bigIntParser(nftItem.token_balance),
                                token_price_wei: bigIntParser(nftItem.token_price_wei),
                            }))
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetNativeTokenBalanceQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `blockHeight`: Ending block to define a block range. Omitting this parameter defaults to the latest block height.
     *
     */
    async getNativeTokenBalance(chainName, walletAddress, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/address/${walletAddress}/balances_native`, [
            {
                key: "quote-currency",
                value: queryParamOpts?.quoteCurrency,
            },
            {
                key: "block-height",
                value: queryParamOpts?.blockHeight,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((balanceItem) => ({
                        ...balanceItem,
                        balance: bigIntParser(balanceItem.balance),
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
}

/**
 * Base API
 *
 */
class BaseService {
    constructor(execution) {
        this.execution = execution;
    }
    /**
     *
     * Commonly used to fetch and render a single block for a block explorer.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} blockHeight - The block height or `latest` for the latest block available.
     *
     */
    async getBlock(chainName, blockHeight) {
        const endpoint = endpointGenerator(`${chainName}/block_v2/${blockHeight}`, []);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((blockItem) => ({
                        ...blockItem,
                        signed_at: blockItem.signed_at
                            ? new Date(blockItem.signed_at)
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to resolve ENS, RNS and Unstoppable Domains addresses.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getResolvedAddress(chainName, walletAddress) {
        const endpoint = endpointGenerator(`${chainName}/address/${walletAddress}/resolve_address`, []);
        const parseData = (data) => {
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to get all the block heights within a particular date range. Useful for rendering a display where you sort blocks by day.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} startDate - The start date in YYYY-MM-DD format.
     * @param {string} endDate - The end date in YYYY-MM-DD format.
     * @param {GetBlockHeightsQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async *getBlockHeights(chainName, startDate, endDate, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/block_v2/${startDate}/${endDate}`, [
            {
                key: "page-size",
                value: queryParamOpts?.pageSize,
            },
            {
                key: "page-number",
                value: queryParamOpts?.pageNumber,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((blockItem) => ({
                        ...blockItem,
                        signed_at: blockItem.signed_at
                            ? new Date(blockItem.signed_at)
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        for await (const data of paginateEndpoint(endpoint, this.execution, parseData, "pagination")) {
            yield data;
        }
    }
    /**
     *
     * Commonly used to get all the block heights within a particular date range. Useful for rendering a display where you sort blocks by day.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} startDate - The start date in YYYY-MM-DD format.
     * @param {string} endDate - The end date in YYYY-MM-DD format.
     * @param {GetBlockHeightsQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getBlockHeightsByPage(chainName, startDate, endDate, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/block_v2/${startDate}/${endDate}`, [
            {
                key: "page-size",
                value: queryParamOpts?.pageSize,
            },
            {
                key: "page-number",
                value: queryParamOpts?.pageNumber,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((blockItem) => ({
                        ...blockItem,
                        signed_at: blockItem.signed_at
                            ? new Date(blockItem.signed_at)
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to get all the event logs of the latest block, or for a range of blocks. Includes sender contract metadata as well as decoded logs.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {GetLogsQueryParamOpts} queryParamOpts
     *   - `startingBlock`: The first block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `endingBlock`: The last block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `address`: The address of the log events sender contract.
     *   - `topics`: The topic hash(es) to retrieve logs with.
     *   - `blockHash`: The block hash to retrieve logs for.
     *   - `skipDecode`: Omit decoded log events.
     *
     */
    async getLogs(chainName, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/events`, [
            {
                key: "starting-block",
                value: queryParamOpts?.startingBlock,
            },
            {
                key: "ending-block",
                value: queryParamOpts?.endingBlock,
            },
            {
                key: "address",
                value: queryParamOpts?.address,
            },
            {
                key: "topics",
                value: queryParamOpts?.topics,
            },
            {
                key: "block-hash",
                value: queryParamOpts?.blockHash,
            },
            {
                key: "skip-decode",
                value: queryParamOpts?.skipDecode,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((logItem) => ({
                        ...logItem,
                        block_signed_at: logItem.block_signed_at
                            ? new Date(logItem.block_signed_at)
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to get all the event logs emitted from a particular contract address. Useful for building dashboards that examine on-chain interactions.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetLogEventsByAddressQueryParamOpts} queryParamOpts
     *   - `startingBlock`: The first block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `endingBlock`: The last block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async *getLogEventsByAddress(chainName, contractAddress, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/events/address/${contractAddress}`, [
            {
                key: "starting-block",
                value: queryParamOpts?.startingBlock,
            },
            {
                key: "ending-block",
                value: queryParamOpts?.endingBlock,
            },
            {
                key: "page-size",
                value: queryParamOpts?.pageSize,
            },
            {
                key: "page-number",
                value: queryParamOpts?.pageNumber,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((logItem) => ({
                        ...logItem,
                        block_signed_at: logItem.block_signed_at
                            ? new Date(logItem.block_signed_at)
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        for await (const data of paginateEndpoint(endpoint, this.execution, parseData, "pagination")) {
            yield data;
        }
    }
    /**
     *
     * Commonly used to get all the event logs emitted from a particular contract address. Useful for building dashboards that examine on-chain interactions.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetLogEventsByAddressQueryParamOpts} queryParamOpts
     *   - `startingBlock`: The first block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `endingBlock`: The last block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getLogEventsByAddressByPage(chainName, contractAddress, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/events/address/${contractAddress}`, [
            {
                key: "starting-block",
                value: queryParamOpts?.startingBlock,
            },
            {
                key: "ending-block",
                value: queryParamOpts?.endingBlock,
            },
            {
                key: "page-size",
                value: queryParamOpts?.pageSize,
            },
            {
                key: "page-number",
                value: queryParamOpts?.pageNumber,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((logItem) => ({
                        ...logItem,
                        block_signed_at: logItem.block_signed_at
                            ? new Date(logItem.block_signed_at)
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to get all event logs of the same topic hash across all contracts within a particular chain. Useful for cross-sectional analysis of event logs that are emitted on-chain.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} topicHash - The endpoint will return event logs that contain this topic hash.
     * @param {GetLogEventsByTopicHashQueryParamOpts} queryParamOpts
     *   - `startingBlock`: The first block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `endingBlock`: The last block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `secondaryTopics`: Additional topic hash(es) to filter on - padded & unpadded address fields are supported. Separate multiple topics with a comma.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async *getLogEventsByTopicHash(chainName, topicHash, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/events/topics/${topicHash}`, [
            {
                key: "starting-block",
                value: queryParamOpts?.startingBlock,
            },
            {
                key: "ending-block",
                value: queryParamOpts?.endingBlock,
            },
            {
                key: "secondary-topics",
                value: queryParamOpts?.secondaryTopics,
            },
            {
                key: "page-size",
                value: queryParamOpts?.pageSize,
            },
            {
                key: "page-number",
                value: queryParamOpts?.pageNumber,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((logItem) => ({
                        ...logItem,
                        block_signed_at: logItem.block_signed_at
                            ? new Date(logItem.block_signed_at)
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        for await (const data of paginateEndpoint(endpoint, this.execution, parseData, "pagination")) {
            yield data;
        }
    }
    /**
     *
     * Commonly used to get all event logs of the same topic hash across all contracts within a particular chain. Useful for cross-sectional analysis of event logs that are emitted on-chain.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} topicHash - The endpoint will return event logs that contain this topic hash.
     * @param {GetLogEventsByTopicHashQueryParamOpts} queryParamOpts
     *   - `startingBlock`: The first block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `endingBlock`: The last block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `secondaryTopics`: Additional topic hash(es) to filter on - padded & unpadded address fields are supported. Separate multiple topics with a comma.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getLogEventsByTopicHashByPage(chainName, topicHash, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/events/topics/${topicHash}`, [
            {
                key: "starting-block",
                value: queryParamOpts?.startingBlock,
            },
            {
                key: "ending-block",
                value: queryParamOpts?.endingBlock,
            },
            {
                key: "secondary-topics",
                value: queryParamOpts?.secondaryTopics,
            },
            {
                key: "page-size",
                value: queryParamOpts?.pageSize,
            },
            {
                key: "page-number",
                value: queryParamOpts?.pageNumber,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((logItem) => ({
                        ...logItem,
                        block_signed_at: logItem.block_signed_at
                            ? new Date(logItem.block_signed_at)
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to build internal dashboards for all supported chains on Covalent.
     *
     *
     */
    async getAllChains() {
        const endpoint = endpointGenerator(`chains`);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((chainItem) => ({
                        ...chainItem,
                        chain_id: chainItem.chain_id ? +chainItem.chain_id : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to build internal status dashboards of all supported chains.
     *
     *
     */
    async getAllChainStatus() {
        const endpoint = endpointGenerator(`chains/status`);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((chainItem) => ({
                        ...chainItem,
                        chain_id: chainItem.chain_id ? +chainItem.chain_id : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to locate chains which an address is active on with a single API call.
     *
     * @param {string} walletAddress - The requested wallet address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetAddressActivityQueryParamOpts} queryParamOpts
     *   - `testnets`: Set to true to include testnets with activity in the response. By default, it's set to `false` and only returns mainnet activity.
     *
     */
    async getAddressActivity(walletAddress, queryParamOpts) {
        const endpoint = endpointGenerator(`address/${walletAddress}/activity`, [
            {
                key: "testnets",
                value: queryParamOpts?.testnets,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((activityItem) => ({
                        ...activityItem,
                        last_seen_at: activityItem.last_seen_at
                            ? new Date(activityItem.last_seen_at)
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} eventType - The desired event type to retrieve gas prices for. Supports `erc20` transfer events, `uniswapv3` swap events and `nativetokens` transfers.
     * @param {GetGasPricesQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *
     */
    async getGasPrices(chainName, eventType, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/event/${eventType}/gas_prices`, [
            {
                key: "quote-currency",
                value: queryParamOpts?.quoteCurrency,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.base_fee = bigIntParser(data.data.base_fee);
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
}

/**
 * NFTs API
 *
 */
class NftService {
    constructor(execution) {
        this.execution = execution;
    }
    /**
     *
     * Commonly used to fetch the list of NFT collections with downloaded and cached off chain data like token metadata and asset files.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {GetChainCollectionsQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *
     */
    async *getChainCollections(chainName, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/nft/collections`, [
            {
                key: "page-size",
                value: queryParamOpts?.pageSize,
            },
            {
                key: "page-number",
                value: queryParamOpts?.pageNumber,
            },
            {
                key: "no-spam",
                value: queryParamOpts?.noSpam,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((collectionItem) => ({
                        ...collectionItem,
                        last_scraped_at: collectionItem.last_scraped_at
                            ? new Date(collectionItem.last_scraped_at)
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        for await (const data of paginateEndpoint(endpoint, this.execution, parseData, "pagination")) {
            yield data;
        }
    }
    /**
     *
     * Commonly used to fetch the list of NFT collections with downloaded and cached off chain data like token metadata and asset files.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {GetChainCollectionsQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *
     */
    async getChainCollectionsByPage(chainName, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/nft/collections`, [
            {
                key: "page-size",
                value: queryParamOpts?.pageSize,
            },
            {
                key: "page-number",
                value: queryParamOpts?.pageNumber,
            },
            {
                key: "no-spam",
                value: queryParamOpts?.noSpam,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((collectionItem) => ({
                        ...collectionItem,
                        last_scraped_at: collectionItem.last_scraped_at
                            ? new Date(collectionItem.last_scraped_at)
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to render the NFTs (including ERC721 and ERC1155) held by an address.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetNftsForAddressQueryParamOpts} queryParamOpts
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *   - `noNftAssetMetadata`: If `true`, the response shape is limited to a list of collections and token ids, omitting metadata and asset information. Helpful for faster response times and wallets holding a large number of NFTs.
     *   - `withUncached`: By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side.
     *
     */
    async getNftsForAddress(chainName, walletAddress, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/address/${walletAddress}/balances_nft`, [
            {
                key: "no-spam",
                value: queryParamOpts?.noSpam,
            },
            {
                key: "no-nft-asset-metadata",
                value: queryParamOpts?.noNftAssetMetadata,
            },
            {
                key: "with-uncached",
                value: queryParamOpts?.withUncached,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((balanceItem) => ({
                        ...balanceItem,
                        balance: bigIntParser(balanceItem.balance),
                        balance_24h: bigIntParser(balanceItem.balance_24h),
                        nft_data: balanceItem.nft_data
                            ? balanceItem.nft_data.map((nftItem) => ({
                                ...nftItem,
                                token_id: bigIntParser(nftItem.token_id),
                            }))
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to get NFT token IDs with metadata from a collection. Useful for building NFT card displays.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTokenIdsForContractWithMetadataQueryParamOpts} queryParamOpts
     *   - `noMetadata`: Omit metadata.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `traitsFilter`: Filters NFTs based on a specific trait. If this filter is used, the API will return all NFTs with the specified trait. Accepts comma-separated values, is case-sensitive, and requires proper URL encoding.
     *   - `valuesFilter`: Filters NFTs based on a specific trait value. If this filter is used, the API will return all NFTs with the specified trait value. If used with "traits-filter", only NFTs matching both filters will be returned. Accepts comma-separated values, is case-sensitive, and requires proper URL encoding.
     *   - `withUncached`: By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side.
     *
     */
    async *getTokenIdsForContractWithMetadata(chainName, contractAddress, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/nft/${contractAddress}/metadata`, [
            {
                key: "no-metadata",
                value: queryParamOpts?.noMetadata,
            },
            {
                key: "page-size",
                value: queryParamOpts?.pageSize,
            },
            {
                key: "page-number",
                value: queryParamOpts?.pageNumber,
            },
            {
                key: "traits-filter",
                value: queryParamOpts?.traitsFilter,
            },
            {
                key: "values-filter",
                value: queryParamOpts?.valuesFilter,
            },
            {
                key: "with-uncached",
                value: queryParamOpts?.withUncached,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((tokenItem) => ({
                        ...tokenItem,
                        nft_data: {
                            ...tokenItem.nft_data,
                            token_id: bigIntParser(tokenItem.nft_data?.token_id),
                        },
                    }))
                    : null;
            }
            return data;
        };
        for await (const data of paginateEndpoint(endpoint, this.execution, parseData, "pagination")) {
            yield data;
        }
    }
    /**
     *
     * Commonly used to get NFT token IDs with metadata from a collection. Useful for building NFT card displays.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTokenIdsForContractWithMetadataQueryParamOpts} queryParamOpts
     *   - `noMetadata`: Omit metadata.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `traitsFilter`: Filters NFTs based on a specific trait. If this filter is used, the API will return all NFTs with the specified trait. Accepts comma-separated values, is case-sensitive, and requires proper URL encoding.
     *   - `valuesFilter`: Filters NFTs based on a specific trait value. If this filter is used, the API will return all NFTs with the specified trait value. If used with "traits-filter", only NFTs matching both filters will be returned. Accepts comma-separated values, is case-sensitive, and requires proper URL encoding.
     *   - `withUncached`: By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side.
     *
     */
    async getTokenIdsForContractWithMetadataByPage(chainName, contractAddress, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/nft/${contractAddress}/metadata`, [
            {
                key: "no-metadata",
                value: queryParamOpts?.noMetadata,
            },
            {
                key: "page-size",
                value: queryParamOpts?.pageSize,
            },
            {
                key: "page-number",
                value: queryParamOpts?.pageNumber,
            },
            {
                key: "traits-filter",
                value: queryParamOpts?.traitsFilter,
            },
            {
                key: "values-filter",
                value: queryParamOpts?.valuesFilter,
            },
            {
                key: "with-uncached",
                value: queryParamOpts?.withUncached,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((tokenItem) => ({
                        ...tokenItem,
                        nft_data: {
                            ...tokenItem.nft_data,
                            token_id: bigIntParser(tokenItem.nft_data?.token_id),
                        },
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to get a single NFT metadata by token ID from a collection. Useful for building NFT card displays.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} tokenId - The requested token ID.
     * @param {GetNftMetadataForGivenTokenIdForContractQueryParamOpts} queryParamOpts
     *   - `noMetadata`: Omit metadata.
     *   - `withUncached`: By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side.
     *
     */
    async getNftMetadataForGivenTokenIdForContract(chainName, contractAddress, tokenId, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/nft/${contractAddress}/metadata/${tokenId}`, [
            {
                key: "no-metadata",
                value: queryParamOpts?.noMetadata,
            },
            {
                key: "with-uncached",
                value: queryParamOpts?.withUncached,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((tokenItem) => ({
                        ...tokenItem,
                        nft_data: {
                            ...tokenItem.nft_data,
                            token_id: bigIntParser(tokenItem.nft_data?.token_id),
                        },
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to get all transactions of an NFT token. Useful for building a transaction history table or price chart.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} tokenId - The requested token ID.
     * @param {GetNftTransactionsForContractTokenIdQueryParamOpts} queryParamOpts
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *
     */
    async getNftTransactionsForContractTokenId(chainName, contractAddress, tokenId, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/tokens/${contractAddress}/nft_transactions/${tokenId}`, [
            {
                key: "no-spam",
                value: queryParamOpts?.noSpam,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((nftItem) => ({
                        ...nftItem,
                        nft_transactions: nftItem.nft_transactions
                            ? nftItem.nft_transactions.map((txItem) => ({
                                ...txItem,
                                block_signed_at: txItem.block_signed_at
                                    ? new Date(txItem.block_signed_at)
                                    : null,
                                value: bigIntParser(txItem.value),
                                fees_paid: bigIntParser(txItem.fees_paid),
                                log_events: txItem.log_events
                                    ? txItem.log_events.map((logItem) => ({
                                        ...logItem,
                                        block_signed_at: logItem.block_signed_at
                                            ? new Date(logItem.block_signed_at)
                                            : null,
                                    }))
                                    : null,
                            }))
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to fetch and render the traits of a collection as seen in rarity calculators.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} collectionContract - The requested collection address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getTraitsForCollection(chainName, collectionContract) {
        const endpoint = endpointGenerator(`${chainName}/nft/${collectionContract}/traits`, []);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to get the count of unique values for traits within an NFT collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} collectionContract - The requested collection address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} trait - The requested trait.
     *
     */
    async getAttributesForTraitInCollection(chainName, collectionContract, trait) {
        const endpoint = endpointGenerator(`${chainName}/nft/${collectionContract}/traits/${trait}/attributes`, []);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to calculate rarity scores for a collection based on its traits.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} collectionContract - The requested collection address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getCollectionTraitsSummary(chainName, collectionContract) {
        const endpoint = endpointGenerator(`${chainName}/nft/${collectionContract}/traits_summary`, []);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to verify ownership of NFTs (including ERC-721 and ERC-1155) within a collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} collectionContract - The requested collection address.
     * @param {CheckOwnershipInNftQueryParamOpts} queryParamOpts
     *   - `traitsFilter`: Filters NFTs based on a specific trait. If this filter is used, the API will return all NFTs with the specified trait. Must be used with "values-filter", is case-sensitive, and requires proper URL encoding.
     *   - `valuesFilter`: Filters NFTs based on a specific trait value. If this filter is used, the API will return all NFTs with the specified trait value. Must be used with "traits-filter", is case-sensitive, and requires proper URL encoding.
     *
     */
    async checkOwnershipInNft(chainName, walletAddress, collectionContract, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/address/${walletAddress}/collection/${collectionContract}`, [
            {
                key: "traits-filter",
                value: queryParamOpts?.traitsFilter,
            },
            {
                key: "values-filter",
                value: queryParamOpts?.valuesFilter,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((nftItem) => ({
                        ...nftItem,
                        balance: bigIntParser(nftItem.balance),
                        balance_24h: bigIntParser(nftItem.balance_24h),
                        token_id: bigIntParser(nftItem.token_id),
                        nft_data: {
                            ...nftItem.nft_data,
                            token_id: bigIntParser(nftItem.nft_data?.token_id),
                        },
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to verify ownership of a specific token (ERC-721 or ERC-1155) within a collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} collectionContract - The requested collection address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} tokenId - The requested token ID.
     *
     */
    async checkOwnershipInNftForSpecificTokenId(chainName, walletAddress, collectionContract, tokenId) {
        const endpoint = endpointGenerator(`${chainName}/address/${walletAddress}/collection/${collectionContract}/token/${tokenId}`, []);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((balanceItem) => ({
                        ...balanceItem,
                        balance: bigIntParser(balanceItem.balance),
                        balance_24h: bigIntParser(balanceItem.balance_24h),
                        token_id: bigIntParser(balanceItem.token_id),
                        last_transfered_at: balanceItem.last_transfered_at
                            ? new Date(balanceItem.last_transfered_at)
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
}

/**
 * Pricing API
 *
 */
class PricingService {
    constructor(execution) {
        this.execution = execution;
    }
    /**
     *
     * Commonly used to get historic prices of a token between date ranges. Supports native tokens.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} quoteCurrency - The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     * @param {string} contractAddress - Contract address for the token. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically. Supports multiple contract addresses separated by commas.
     * @param {GetTokenPricesQueryParamOpts} queryParamOpts
     *   - `from`: The start day of the historical price range (YYYY-MM-DD).
     *   - `to`: The end day of the historical price range (YYYY-MM-DD).
     *   - `pricesAtAsc`: Sort the prices in chronological ascending order. By default, it's set to `false` and returns prices in chronological descending order.
     *
     */
    async getTokenPrices(chainName, quoteCurrency, contractAddress, queryParamOpts) {
        const endpoint = endpointGenerator(`pricing/historical_by_addresses_v2/${chainName}/${quoteCurrency}/${contractAddress}`, [
            {
                key: "from",
                value: queryParamOpts?.from,
            },
            {
                key: "to",
                value: queryParamOpts?.to,
            },
            {
                key: "prices-at-asc",
                value: queryParamOpts?.pricesAtAsc,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.forEach((dataItem) => {
                    dataItem.update_at = dataItem.update_at
                        ? new Date(dataItem.update_at)
                        : null;
                    dataItem.items = dataItem.items
                        ? dataItem.items.map((priceItem) => ({
                            ...priceItem,
                            date: priceItem.date ? new Date(priceItem.date) : null,
                        }))
                        : null;
                });
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
}

/**
 * Approvals API
 *
 */
class SecurityService {
    constructor(execution) {
        this.execution = execution;
    }
    /**
     *
     * Commonly used to get a list of approvals across all token contracts categorized by spenders for a wallets assets.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getApprovals(chainName, walletAddress) {
        const endpoint = endpointGenerator(`${chainName}/approvals/${walletAddress}`, []);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((approvalItem) => ({
                        ...approvalItem,
                        balance: bigIntParser(approvalItem.balance),
                        spenders: approvalItem.spenders
                            ? approvalItem.spenders.map((spenderItem) => ({
                                ...spenderItem,
                                block_signed_at: spenderItem.block_signed_at
                                    ? new Date(spenderItem.block_signed_at)
                                    : null,
                            }))
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
       *
       * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
       * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
       
       *
       */
    async getNftApprovals(chainName, walletAddress) {
        const endpoint = endpointGenerator(`${chainName}/nft/approvals/${walletAddress}`, []);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((approvalItem) => ({
                        ...approvalItem,
                        token_balances: approvalItem.token_balances
                            ? approvalItem.token_balances.map((balanceItem) => ({
                                ...balanceItem,
                                token_balance: bigIntParser(balanceItem.token_balance),
                                token_id: bigIntParser(balanceItem.token_id),
                            }))
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
}

/**
 * Transactions API
 *
 */
class TransactionService {
    constructor(execution) {
        this.execution = execution;
    }
    /**
     *
     * Commonly used to fetch and render a single transaction including its decoded log events. Additionally return semantically decoded information for DEX trades, lending and NFT sales.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} txHash - The transaction hash.
     * @param {GetTransactionQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `withSafe`: Include safe details.
     *
     */
    async getTransaction(chainName, txHash, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/transaction_v2/${txHash}`, [
            {
                key: "quote-currency",
                value: queryParamOpts?.quoteCurrency,
            },
            {
                key: "no-logs",
                value: queryParamOpts?.noLogs,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((txItem) => ({
                        ...txItem,
                        value: bigIntParser(txItem.value),
                        fees_paid: bigIntParser(txItem.fees_paid),
                        block_signed_at: txItem.block_signed_at
                            ? new Date(txItem.block_signed_at)
                            : null,
                        log_events: txItem.log_events
                            ? txItem.log_events.map((logItem) => ({
                                ...logItem,
                                block_signed_at: logItem.block_signed_at
                                    ? new Date(logItem.block_signed_at)
                                    : null,
                            }))
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to fetch and render the most recent transactions involving an address. Frequently seen in wallet applications.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetAllTransactionsForAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `blockSignedAtAsc`: Sort the transactions in ascending chronological order. By default, it's set to `false` and returns transactions in descending chronological order.
     *   - `withSafe`: Include safe details.
     *
     */
    async *getAllTransactionsForAddress(chainName, walletAddress, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/address/${walletAddress}/transactions_v3`, [
            {
                key: "quote-currency",
                value: queryParamOpts?.quoteCurrency,
            },
            {
                key: "no-logs",
                value: queryParamOpts?.noLogs,
            },
            {
                key: "block-signed-at-asc",
                value: queryParamOpts?.blockSignedAtAsc,
            },
            {
                key: "with-safe",
                value: queryParamOpts?.withSafe,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((txItem) => ({
                        ...txItem,
                        value: bigIntParser(txItem.value),
                        fees_paid: bigIntParser(txItem.fees_paid),
                        block_signed_at: txItem.block_signed_at
                            ? new Date(txItem.block_signed_at)
                            : null,
                        log_events: txItem.log_events
                            ? txItem.log_events.map((logItem) => ({
                                ...logItem,
                                block_signed_at: logItem.block_signed_at
                                    ? new Date(logItem.block_signed_at)
                                    : null,
                            }))
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        for await (const data of paginateEndpoint(endpoint, this.execution, parseData, "links")) {
            yield data;
        }
    }
    /**
     *
     * Commonly used to fetch and render the most recent transactions involving an address. Frequently seen in wallet applications.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetAllTransactionsForAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `blockSignedAtAsc`: Sort the transactions in ascending chronological order. By default, it's set to `false` and returns transactions in descending chronological order.
     *   - `withSafe`: Include safe details.
     *
     */
    async getAllTransactionsForAddressByPage(chainName, walletAddress, queryParamOpts) {
        const searchParams = [
            {
                key: "quote-currency",
                value: queryParamOpts?.quoteCurrency,
            },
            {
                key: "no-logs",
                value: queryParamOpts?.noLogs,
            },
            {
                key: "block-signed-at-asc",
                value: queryParamOpts?.blockSignedAtAsc,
            },
            {
                key: "with-safe",
                value: queryParamOpts?.withSafe,
            },
        ];
        const endpoint = endpointGenerator(`${chainName}/address/${walletAddress}/transactions_v3`, searchParams);
        const parseData = (data) => {
            if (data.data) {
                data.data.prev = data.data?.links?.prev
                    ? async () => this.execution.execute(endpointGenerator(data.data?.links?.prev, searchParams), parseData)
                    : null;
                data.data.next = data.data?.links?.next
                    ? async () => this.execution.execute(endpointGenerator(data.data?.links?.next, searchParams), parseData)
                    : null;
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((txItem) => ({
                        ...txItem,
                        value: bigIntParser(txItem.value),
                        fees_paid: bigIntParser(txItem.fees_paid),
                        block_signed_at: txItem.block_signed_at
                            ? new Date(txItem.block_signed_at)
                            : null,
                        log_events: txItem.log_events
                            ? txItem.log_events.map((logItem) => ({
                                ...logItem,
                                block_signed_at: logItem.block_signed_at
                                    ? new Date(logItem.block_signed_at)
                                    : null,
                            }))
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to fetch all transactions including their decoded log events in a block and further flag interesting wallets or transactions.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {number} blockHeight - The requested block height.
     * @param {GetTransactionsForBlockQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `withSafe`: Include safe details.
     *
     */
    async getTransactionsForBlock(chainName, blockHeight, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/block/${blockHeight}/transactions_v3`, [
            {
                key: "quote-currency",
                value: queryParamOpts?.quoteCurrency,
            },
            {
                key: "no-logs",
                value: queryParamOpts?.noLogs,
            },
            {
                key: "with-safe",
                value: queryParamOpts?.withSafe,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((txItem) => ({
                        ...txItem,
                        value: bigIntParser(txItem.value),
                        fees_paid: bigIntParser(txItem.fees_paid),
                        block_signed_at: txItem.block_signed_at
                            ? new Date(txItem.block_signed_at)
                            : null,
                        log_events: txItem.log_events
                            ? txItem.log_events.map((logItem) => ({
                                ...logItem,
                                block_signed_at: logItem.block_signed_at
                                    ? new Date(logItem.block_signed_at)
                                    : null,
                            }))
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to fetch the earliest and latest transactions, and the transaction count for a wallet. Calculate the age of the wallet and the time it has been idle and quickly gain insights into their engagement with web3.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTransactionSummaryQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `withGas`: Include gas summary details. Additional charge of 1 credit when true. Response times may be impacted for wallets with millions of transactions.
     *
     */
    async getTransactionSummary(chainName, walletAddress, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/address/${walletAddress}/transactions_summary`, [
            {
                key: "quote-currency",
                value: queryParamOpts?.quoteCurrency,
            },
            {
                key: "with-gas",
                value: queryParamOpts?.withGas,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((txsItem) => ({
                        ...txsItem,
                        earliest_transaction: {
                            ...txsItem.earliest_transaction,
                            block_signed_at: txsItem?.earliest_transaction?.block_signed_at
                                ? new Date(txsItem.earliest_transaction.block_signed_at)
                                : null,
                        },
                        latest_transaction: {
                            ...txsItem.latest_transaction,
                            block_signed_at: txsItem?.latest_transaction?.block_signed_at
                                ? new Date(txsItem?.latest_transaction?.block_signed_at)
                                : null,
                        },
                        // ? API vs docs non-consistent
                        // gas_summary: {
                        //   ...txsItem.gas_summary,
                        //   total_fees_paid: bigIntParser(
                        //     txsItem.gas_summary.total_fees_paid
                        //   ),
                        // },
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {number} page - The requested page, 0-indexed.
     * @param {GetTransactionsForAddressV3QueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `blockSignedAtAsc`: Sort the transactions in ascending chronological order. By default, it's set to `false` and returns transactions in descending chronological order.
     *   - `withSafe`: Include safe details.
     *
     */
    async getTransactionsForAddressV3(chainName, walletAddress, page, queryParamOpts) {
        const searchParams = [
            {
                key: "quote-currency",
                value: queryParamOpts?.quoteCurrency,
            },
            {
                key: "no-logs",
                value: queryParamOpts?.noLogs,
            },
            {
                key: "block-signed-at-asc",
                value: queryParamOpts?.blockSignedAtAsc,
            },
            {
                key: "with-safe",
                value: queryParamOpts?.withSafe,
            },
        ];
        const endpoint = endpointGenerator(`${chainName}/address/${walletAddress}/transactions_v3/page/${page}`, searchParams);
        const parseData = (data) => {
            if (data.data) {
                data.data.prev = data.data?.links?.prev
                    ? async () => this.execution.execute(endpointGenerator(data.data?.links?.prev, searchParams), parseData)
                    : null;
                data.data.next = data.data?.links?.next
                    ? async () => this.execution.execute(endpointGenerator(data.data?.links?.next, searchParams), parseData)
                    : null;
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((txItem) => ({
                        ...txItem,
                        value: bigIntParser(txItem.value),
                        fees_paid: bigIntParser(txItem.fees_paid),
                        block_signed_at: txItem.block_signed_at
                            ? new Date(txItem.block_signed_at)
                            : null,
                        log_events: txItem.log_events
                            ? txItem.log_events.map((logItem) => ({
                                ...logItem,
                                block_signed_at: logItem.block_signed_at
                                    ? new Date(logItem.block_signed_at)
                                    : null,
                            }))
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {number} timeBucket - The 0-indexed 15-minute time bucket. E.g. 27 Feb 2023 05:23 GMT = 1677475383 (Unix time). 1677475383/900=1863861 timeBucket.
     * @param {GetTimeBucketTransactionsForAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `withSafe`: Include safe details.
     *
     */
    async getTimeBucketTransactionsForAddress(chainName, walletAddress, timeBucket, queryParamOpts) {
        const searchParams = [
            {
                key: "quote-currency",
                value: queryParamOpts?.quoteCurrency,
            },
            {
                key: "no-logs",
                value: queryParamOpts?.noLogs,
            },
            {
                key: "with-safe",
                value: queryParamOpts?.withSafe,
            },
        ];
        const endpoint = endpointGenerator(`${chainName}/bulk/transactions/${walletAddress}/${timeBucket}`, searchParams);
        const parseData = (data) => {
            if (data.data) {
                data.data.prev = data.data?.links?.prev
                    ? async () => this.execution.execute(endpointGenerator(data.data?.links?.prev, searchParams), parseData)
                    : null;
                data.data.next = data.data?.links?.next
                    ? async () => this.execution.execute(endpointGenerator(data.data?.links?.next, searchParams), parseData)
                    : null;
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((txItem) => ({
                        ...txItem,
                        value: bigIntParser(txItem.value),
                        fees_paid: bigIntParser(txItem.fees_paid),
                        block_signed_at: txItem.block_signed_at
                            ? new Date(txItem.block_signed_at)
                            : null,
                        log_events: txItem.log_events
                            ? txItem.log_events.map((logItem) => ({
                                ...logItem,
                                block_signed_at: logItem.block_signed_at
                                    ? new Date(logItem.block_signed_at)
                                    : null,
                            }))
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to fetch all transactions including their decoded log events in a block and further flag interesting wallets or transactions.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} blockHash - The requested block hash.
     * @param {number} page - The requested 0-indexed page number.
     * @param {GetTransactionsForBlockHashByPageQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `withSafe`: Include safe details.
     *
     */
    async getTransactionsForBlockHashByPage(chainName, blockHash, page, queryParamOpts) {
        const searchParams = [
            {
                key: "quote-currency",
                value: queryParamOpts?.quoteCurrency,
            },
            {
                key: "no-logs",
                value: queryParamOpts?.noLogs,
            },
            {
                key: "with-safe",
                value: queryParamOpts?.withSafe,
            },
        ];
        const endpoint = endpointGenerator(`${chainName}/block_hash/${blockHash}/transactions_v3/page/${page}`, searchParams);
        const parseData = (data) => {
            if (data.data) {
                data.data.prev = data.data?.links?.prev
                    ? async () => this.execution.execute(endpointGenerator(data.data?.links?.prev, searchParams), parseData)
                    : null;
                data.data.next = data.data?.links?.next
                    ? async () => this.execution.execute(endpointGenerator(data.data?.links?.next, searchParams), parseData)
                    : null;
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((txItem) => ({
                        ...txItem,
                        value: bigIntParser(txItem.value),
                        fees_paid: bigIntParser(txItem.fees_paid),
                        block_signed_at: txItem.block_signed_at
                            ? new Date(txItem.block_signed_at)
                            : null,
                        log_events: txItem.log_events
                            ? txItem.log_events.map((logItem) => ({
                                ...logItem,
                                block_signed_at: logItem.block_signed_at
                                    ? new Date(logItem.block_signed_at)
                                    : null,
                            }))
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
    /**
     *
     * Commonly used to fetch all transactions including their decoded log events in a block and further flag interesting wallets or transactions.
     *
     * @param {Chain} chainName - The chain name eg: `eth-mainnet` or 1.
     * @param {string} blockHash - The requested block hash.
     * @param {GetTransactionsForBlockHashQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `withSafe`: Include safe details.
     *
     */
    async getTransactionsForBlockHash(chainName, blockHash, queryParamOpts) {
        const endpoint = endpointGenerator(`${chainName}/block_hash/${blockHash}/transactions_v3`, [
            {
                key: "quote-currency",
                value: queryParamOpts?.quoteCurrency,
            },
            {
                key: "no-logs",
                value: queryParamOpts?.noLogs,
            },
            {
                key: "with-safe",
                value: queryParamOpts?.withSafe,
            },
        ]);
        const parseData = (data) => {
            if (data.data) {
                data.data.updated_at = data.data.updated_at
                    ? new Date(data.data.updated_at)
                    : null;
                data.data.items = data.data.items
                    ? data.data.items.map((txItem) => ({
                        ...txItem,
                        value: bigIntParser(txItem.value),
                        fees_paid: bigIntParser(txItem.fees_paid),
                        block_signed_at: txItem.block_signed_at
                            ? new Date(txItem.block_signed_at)
                            : null,
                        log_events: txItem.log_events
                            ? txItem.log_events.map((logItem) => ({
                                ...logItem,
                                block_signed_at: logItem.block_signed_at
                                    ? new Date(logItem.block_signed_at)
                                    : null,
                            }))
                            : null,
                    }))
                    : null;
            }
            return data;
        };
        return await this.execution.execute(endpoint, parseData);
    }
}

async function debugOutput(settings, ...content) {
    if (settings.debug) {
        content.forEach((c) => {
            console.info("[DEBUG] |", c);
        });
    }
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

class Node {
	/// value;
	/// next;

	constructor(value) {
		this.value = value;

		// TODO: Remove this when targeting Node.js 12.
		this.next = undefined;
	}
}

let Queue$1 = class Queue {
	// TODO: Use private class fields when targeting Node.js 12.
	// #_head;
	// #_tail;
	// #_size;

	constructor() {
		this.clear();
	}

	enqueue(value) {
		const node = new Node(value);

		if (this._head) {
			this._tail.next = node;
			this._tail = node;
		} else {
			this._head = node;
			this._tail = node;
		}

		this._size++;
	}

	dequeue() {
		const current = this._head;
		if (!current) {
			return;
		}

		this._head = this._head.next;
		this._size--;
		return current.value;
	}

	clear() {
		this._head = undefined;
		this._tail = undefined;
		this._size = 0;
	}

	get size() {
		return this._size;
	}

	* [Symbol.iterator]() {
		let current = this._head;

		while (current) {
			yield current.value;
			current = current.next;
		}
	}
};

var yoctoQueue = Queue$1;

const Queue = yoctoQueue;

const pLimit = concurrency => {
	if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
		throw new TypeError('Expected `concurrency` to be a number from 1 and up');
	}

	const queue = new Queue();
	let activeCount = 0;

	const next = () => {
		activeCount--;

		if (queue.size > 0) {
			queue.dequeue()();
		}
	};

	const run = async (fn, resolve, ...args) => {
		activeCount++;

		const result = (async () => fn(...args))();

		resolve(result);

		try {
			await result;
		} catch {}

		next();
	};

	const enqueue = (fn, resolve, ...args) => {
		queue.enqueue(run.bind(null, fn, resolve, ...args));

		(async () => {
			// This function needs to wait until the next microtask before comparing
			// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously
			// when the run function is dequeued and called. The comparison in the if-statement
			// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.
			await Promise.resolve();

			if (activeCount < concurrency && queue.size > 0) {
				queue.dequeue()();
			}
		})();
	};

	const generator = (fn, ...args) => new Promise(resolve => {
		enqueue(fn, resolve, ...args);
	});

	Object.defineProperties(generator, {
		activeCount: {
			get: () => activeCount
		},
		pendingCount: {
			get: () => queue.size
		},
		clearQueue: {
			value: () => {
				queue.clear();
			}
		}
	});

	return generator;
};

var pLimit_1 = pLimit;

var pLimit$1 = /*@__PURE__*/getDefaultExportFromCjs(pLimit_1);

class Execution {
    constructor(settings, headers) {
        this.settings = settings;
        this.headers = headers;
        this.processes = pLimit$1(this.settings.threadCount ?? 2);
        this.maxRetries = settings.maxRetries ?? 2;
        this.retryDelay = settings.retryDelay ?? 1500;
        this.enableRetry = settings.enableRetry ?? true;
    }
    async execute(endpoint, parseData) {
        let retryCount = 0;
        let completed = false;
        while (!completed) {
            try {
                const startTime = new Date();
                const response = await this.processes(() => fetch(endpoint, {
                    headers: this.headers,
                }));
                debugOutput(this.settings, `Request URL: ${response ? new URL(response.url) : endpoint} | Response code: ${response ? response.status : 429} | Response time: ${(new Date().getTime() - startTime.getTime()).toFixed(2)}ms`);
                if (response.status === null || response.status === 429) {
                    throw new Error(`Received status code: ${response.status ?? 429}`);
                }
                const data = (await response.json());
                if (data.error) {
                    throw data;
                }
                const parsedData = parseData(data);
                completed = true;
                return {
                    data: parsedData.data,
                    error: false,
                    error_code: null,
                    error_message: null,
                };
            }
            catch (error) {
                debugOutput(this.settings, `Request URL: ${endpoint} | Retry Enabled: ${this.enableRetry} | Retry Count: ${retryCount} | Max Retries: ${this.maxRetries} | Retry Delay: ${this.retryDelay}ms`, error);
                if (this.enableRetry &&
                    (error?.error_code === 429 || error?.cause?.code === 429)) {
                    if (retryCount >= this.maxRetries) {
                        completed = true;
                        return {
                            data: null,
                            error: true,
                            error_code: 429,
                            error_message: `${this.maxRetries} retries exceeded`,
                        };
                    }
                    else {
                        retryCount++;
                        await new Promise((resolve) => setTimeout(resolve, this.retryDelay));
                        completed = false;
                    }
                }
                else {
                    completed = true;
                    return {
                        data: null,
                        error: true,
                        error_code: error?.cause?.code || error?.error_code || 500,
                        error_message: error?.cause?.message ||
                            error?.error_message ||
                            "Internal server error",
                    };
                }
            }
        }
        return {
            data: null,
            error: true,
            error_code: 500,
            error_message: "Internal server error",
        };
    }
}

const _apiKeyV1Pattern = /^ckey_([a-f0-9]{27})$/;
const _apiKeyV2Pattern = /^cqt_(wF|rQ)([bcdfghjkmpqrtvwxyBCDFGHJKMPQRTVWXY346789]{26})$/;
const isValidApiKey = (apiKey) => {
    return _apiKeyV1Pattern.test(apiKey) || _apiKeyV2Pattern.test(apiKey);
};

/**
 * GoldRushClient Class
 */
class GoldRushClient {
    constructor(apiKey, settings = {}) {
        this.userAgent = `com.covalenthq.sdk.typescript/${version}`;
        const validKey = isValidApiKey(apiKey);
        if (!validKey) {
            throw {
                data: null,
                error: true,
                error_code: 401,
                error_message: "Invalid or missing API key (sign up at https://goldrush.dev/platform/apikey)",
            };
        }
        const execution = new Execution(settings, {
            Authorization: `Bearer ${apiKey}`,
            "X-Requested-With": settings.source
                ? `${settings.source} (${this.userAgent})`
                : this.userAgent,
        });
        this.BalanceService = new BalanceService(execution);
        this.BaseService = new BaseService(execution);
        this.NftService = new NftService(execution);
        this.PricingService = new PricingService(execution);
        this.SecurityService = new SecurityService(execution);
        this.TransactionService = new TransactionService(execution);
    }
}

/*
 *  big.js v6.2.1
 *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.
 *  Copyright (c) 2022 Michael Mclaughlin
 *  https://github.com/MikeMcl/big.js/LICENCE.md
 */


/************************************** EDITABLE DEFAULTS *****************************************/


  // The default values below must be integers within the stated ranges.

  /*
   * The maximum number of decimal places (DP) of the results of operations involving division:
   * div and sqrt, and pow with negative exponents.
   */
var DP = 20,          // 0 to MAX_DP

  /*
   * The rounding mode (RM) used when rounding to the above decimal places.
   *
   *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)
   *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)
   *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)
   *  3  Away from zero.                                  (ROUND_UP)
   */
  RM = 1,             // 0, 1, 2 or 3

  // The maximum value of DP and Big.DP.
  MAX_DP = 1E6,       // 0 to 1000000

  // The maximum magnitude of the exponent argument to the pow method.
  MAX_POWER = 1E6,    // 1 to 1000000

  /*
   * The negative exponent (NE) at and beneath which toString returns exponential notation.
   * (JavaScript numbers: -7)
   * -1000000 is the minimum recommended exponent value of a Big.
   */
  NE = -7,            // 0 to -1000000

  /*
   * The positive exponent (PE) at and above which toString returns exponential notation.
   * (JavaScript numbers: 21)
   * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.
   */
  PE = 21,            // 0 to 1000000

  /*
   * When true, an error will be thrown if a primitive number is passed to the Big constructor,
   * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a
   * primitive number without a loss of precision.
   */
  STRICT = false,     // true or false


/**************************************************************************************************/


  // Error messages.
  NAME = '[big.js] ',
  INVALID = NAME + 'Invalid ',
  INVALID_DP = INVALID + 'decimal places',
  INVALID_RM = INVALID + 'rounding mode',
  DIV_BY_ZERO = NAME + 'Division by zero',

  // The shared prototype object.
  P = {},
  UNDEFINED = void 0,
  NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;


/*
 * Create and return a Big constructor.
 */
function _Big_() {

  /*
   * The Big constructor and exported function.
   * Create and return a new instance of a Big number object.
   *
   * n {number|string|Big} A numeric value.
   */
  function Big(n) {
    var x = this;

    // Enable constructor usage without new.
    if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);

    // Duplicate.
    if (n instanceof Big) {
      x.s = n.s;
      x.e = n.e;
      x.c = n.c.slice();
    } else {
      if (typeof n !== 'string') {
        if (Big.strict === true && typeof n !== 'bigint') {
          throw TypeError(INVALID + 'value');
        }

        // Minus zero?
        n = n === 0 && 1 / n < 0 ? '-0' : String(n);
      }

      parse(x, n);
    }

    // Retain a reference to this Big constructor.
    // Shadow Big.prototype.constructor which points to Object.
    x.constructor = Big;
  }

  Big.prototype = P;
  Big.DP = DP;
  Big.RM = RM;
  Big.NE = NE;
  Big.PE = PE;
  Big.strict = STRICT;
  Big.roundDown = 0;
  Big.roundHalfUp = 1;
  Big.roundHalfEven = 2;
  Big.roundUp = 3;

  return Big;
}


/*
 * Parse the number or string value passed to a Big constructor.
 *
 * x {Big} A Big number instance.
 * n {number|string} A numeric value.
 */
function parse(x, n) {
  var e, i, nl;

  if (!NUMERIC.test(n)) {
    throw Error(INVALID + 'number');
  }

  // Determine sign.
  x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;

  // Decimal point?
  if ((e = n.indexOf('.')) > -1) n = n.replace('.', '');

  // Exponential form?
  if ((i = n.search(/e/i)) > 0) {

    // Determine exponent.
    if (e < 0) e = i;
    e += +n.slice(i + 1);
    n = n.substring(0, i);
  } else if (e < 0) {

    // Integer.
    e = n.length;
  }

  nl = n.length;

  // Determine leading zeros.
  for (i = 0; i < nl && n.charAt(i) == '0';) ++i;

  if (i == nl) {

    // Zero.
    x.c = [x.e = 0];
  } else {

    // Determine trailing zeros.
    for (; nl > 0 && n.charAt(--nl) == '0';);
    x.e = e - i - 1;
    x.c = [];

    // Convert string to array of digits without leading/trailing zeros.
    for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);
  }

  return x;
}


/*
 * Round Big x to a maximum of sd significant digits using rounding mode rm.
 *
 * x {Big} The Big to round.
 * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.
 * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 * [more] {boolean} Whether the result of division was truncated.
 */
function round(x, sd, rm, more) {
  var xc = x.c;

  if (rm === UNDEFINED) rm = x.constructor.RM;
  if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {
    throw Error(INVALID_RM);
  }

  if (sd < 1) {
    more =
      rm === 3 && (more || !!xc[0]) || sd === 0 && (
      rm === 1 && xc[0] >= 5 ||
      rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED))
    );

    xc.length = 1;

    if (more) {

      // 1, 0.1, 0.01, 0.001, 0.0001 etc.
      x.e = x.e - sd + 1;
      xc[0] = 1;
    } else {

      // Zero.
      xc[0] = x.e = 0;
    }
  } else if (sd < xc.length) {

    // xc[sd] is the digit after the digit that may be rounded up.
    more =
      rm === 1 && xc[sd] >= 5 ||
      rm === 2 && (xc[sd] > 5 || xc[sd] === 5 &&
        (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) ||
      rm === 3 && (more || !!xc[0]);

    // Remove any digits after the required precision.
    xc.length = sd;

    // Round up?
    if (more) {

      // Rounding up may mean the previous digit has to be rounded up.
      for (; ++xc[--sd] > 9;) {
        xc[sd] = 0;
        if (sd === 0) {
          ++x.e;
          xc.unshift(1);
          break;
        }
      }
    }

    // Remove trailing zeros.
    for (sd = xc.length; !xc[--sd];) xc.pop();
  }

  return x;
}


/*
 * Return a string representing the value of Big x in normal or exponential notation.
 * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.
 */
function stringify(x, doExponential, isNonzero) {
  var e = x.e,
    s = x.c.join(''),
    n = s.length;

  // Exponential notation?
  if (doExponential) {
    s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;

  // Normal notation.
  } else if (e < 0) {
    for (; ++e;) s = '0' + s;
    s = '0.' + s;
  } else if (e > 0) {
    if (++e > n) {
      for (e -= n; e--;) s += '0';
    } else if (e < n) {
      s = s.slice(0, e) + '.' + s.slice(e);
    }
  } else if (n > 1) {
    s = s.charAt(0) + '.' + s.slice(1);
  }

  return x.s < 0 && isNonzero ? '-' + s : s;
}


// Prototype/instance methods


/*
 * Return a new Big whose value is the absolute value of this Big.
 */
P.abs = function () {
  var x = new this.constructor(this);
  x.s = 1;
  return x;
};


/*
 * Return 1 if the value of this Big is greater than the value of Big y,
 *       -1 if the value of this Big is less than the value of Big y, or
 *        0 if they have the same value.
 */
P.cmp = function (y) {
  var isneg,
    x = this,
    xc = x.c,
    yc = (y = new x.constructor(y)).c,
    i = x.s,
    j = y.s,
    k = x.e,
    l = y.e;

  // Either zero?
  if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;

  // Signs differ?
  if (i != j) return i;

  isneg = i < 0;

  // Compare exponents.
  if (k != l) return k > l ^ isneg ? 1 : -1;

  j = (k = xc.length) < (l = yc.length) ? k : l;

  // Compare digit by digit.
  for (i = -1; ++i < j;) {
    if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;
  }

  // Compare lengths.
  return k == l ? 0 : k > l ^ isneg ? 1 : -1;
};


/*
 * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,
 * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
P.div = function (y) {
  var x = this,
    Big = x.constructor,
    a = x.c,                  // dividend
    b = (y = new Big(y)).c,   // divisor
    k = x.s == y.s ? 1 : -1,
    dp = Big.DP;

  if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }

  // Divisor is zero?
  if (!b[0]) {
    throw Error(DIV_BY_ZERO);
  }

  // Dividend is 0? Return +-0.
  if (!a[0]) {
    y.s = k;
    y.c = [y.e = 0];
    return y;
  }

  var bl, bt, n, cmp, ri,
    bz = b.slice(),
    ai = bl = b.length,
    al = a.length,
    r = a.slice(0, bl),   // remainder
    rl = r.length,
    q = y,                // quotient
    qc = q.c = [],
    qi = 0,
    p = dp + (q.e = x.e - y.e) + 1;    // precision of the result

  q.s = k;
  k = p < 0 ? 0 : p;

  // Create version of divisor with leading zero.
  bz.unshift(0);

  // Add zeros to make remainder as long as divisor.
  for (; rl++ < bl;) r.push(0);

  do {

    // n is how many times the divisor goes into current remainder.
    for (n = 0; n < 10; n++) {

      // Compare divisor and remainder.
      if (bl != (rl = r.length)) {
        cmp = bl > rl ? 1 : -1;
      } else {
        for (ri = -1, cmp = 0; ++ri < bl;) {
          if (b[ri] != r[ri]) {
            cmp = b[ri] > r[ri] ? 1 : -1;
            break;
          }
        }
      }

      // If divisor < remainder, subtract divisor from remainder.
      if (cmp < 0) {

        // Remainder can't be more than 1 digit longer than divisor.
        // Equalise lengths using divisor with extra leading zero?
        for (bt = rl == bl ? b : bz; rl;) {
          if (r[--rl] < bt[rl]) {
            ri = rl;
            for (; ri && !r[--ri];) r[ri] = 9;
            --r[ri];
            r[rl] += 10;
          }
          r[rl] -= bt[rl];
        }

        for (; !r[0];) r.shift();
      } else {
        break;
      }
    }

    // Add the digit n to the result array.
    qc[qi++] = cmp ? n : ++n;

    // Update the remainder.
    if (r[0] && cmp) r[rl] = a[ai] || 0;
    else r = [a[ai]];

  } while ((ai++ < al || r[0] !== UNDEFINED) && k--);

  // Leading zero? Do not remove if result is simply zero (qi == 1).
  if (!qc[0] && qi != 1) {

    // There can't be more than one zero.
    qc.shift();
    q.e--;
    p--;
  }

  // Round?
  if (qi > p) round(q, p, Big.RM, r[0] !== UNDEFINED);

  return q;
};


/*
 * Return true if the value of this Big is equal to the value of Big y, otherwise return false.
 */
P.eq = function (y) {
  return this.cmp(y) === 0;
};


/*
 * Return true if the value of this Big is greater than the value of Big y, otherwise return
 * false.
 */
P.gt = function (y) {
  return this.cmp(y) > 0;
};


/*
 * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise
 * return false.
 */
P.gte = function (y) {
  return this.cmp(y) > -1;
};


/*
 * Return true if the value of this Big is less than the value of Big y, otherwise return false.
 */
P.lt = function (y) {
  return this.cmp(y) < 0;
};


/*
 * Return true if the value of this Big is less than or equal to the value of Big y, otherwise
 * return false.
 */
P.lte = function (y) {
  return this.cmp(y) < 1;
};


/*
 * Return a new Big whose value is the value of this Big minus the value of Big y.
 */
P.minus = P.sub = function (y) {
  var i, j, t, xlty,
    x = this,
    Big = x.constructor,
    a = x.s,
    b = (y = new Big(y)).s;

  // Signs differ?
  if (a != b) {
    y.s = -b;
    return x.plus(y);
  }

  var xc = x.c.slice(),
    xe = x.e,
    yc = y.c,
    ye = y.e;

  // Either zero?
  if (!xc[0] || !yc[0]) {
    if (yc[0]) {
      y.s = -b;
    } else if (xc[0]) {
      y = new Big(x);
    } else {
      y.s = 1;
    }
    return y;
  }

  // Determine which is the bigger number. Prepend zeros to equalise exponents.
  if (a = xe - ye) {

    if (xlty = a < 0) {
      a = -a;
      t = xc;
    } else {
      ye = xe;
      t = yc;
    }

    t.reverse();
    for (b = a; b--;) t.push(0);
    t.reverse();
  } else {

    // Exponents equal. Check digit by digit.
    j = ((xlty = xc.length < yc.length) ? xc : yc).length;

    for (a = b = 0; b < j; b++) {
      if (xc[b] != yc[b]) {
        xlty = xc[b] < yc[b];
        break;
      }
    }
  }

  // x < y? Point xc to the array of the bigger number.
  if (xlty) {
    t = xc;
    xc = yc;
    yc = t;
    y.s = -y.s;
  }

  /*
   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only
   * needs to start at yc.length.
   */
  if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--;) xc[i++] = 0;

  // Subtract yc from xc.
  for (b = i; j > a;) {
    if (xc[--j] < yc[j]) {
      for (i = j; i && !xc[--i];) xc[i] = 9;
      --xc[i];
      xc[j] += 10;
    }

    xc[j] -= yc[j];
  }

  // Remove trailing zeros.
  for (; xc[--b] === 0;) xc.pop();

  // Remove leading zeros and adjust exponent accordingly.
  for (; xc[0] === 0;) {
    xc.shift();
    --ye;
  }

  if (!xc[0]) {

    // n - n = +0
    y.s = 1;

    // Result must be zero.
    xc = [ye = 0];
  }

  y.c = xc;
  y.e = ye;

  return y;
};


/*
 * Return a new Big whose value is the value of this Big modulo the value of Big y.
 */
P.mod = function (y) {
  var ygtx,
    x = this,
    Big = x.constructor,
    a = x.s,
    b = (y = new Big(y)).s;

  if (!y.c[0]) {
    throw Error(DIV_BY_ZERO);
  }

  x.s = y.s = 1;
  ygtx = y.cmp(x) == 1;
  x.s = a;
  y.s = b;

  if (ygtx) return new Big(x);

  a = Big.DP;
  b = Big.RM;
  Big.DP = Big.RM = 0;
  x = x.div(y);
  Big.DP = a;
  Big.RM = b;

  return this.minus(x.times(y));
};


/*
 * Return a new Big whose value is the value of this Big negated.
 */
P.neg = function () {
  var x = new this.constructor(this);
  x.s = -x.s;
  return x;
};


/*
 * Return a new Big whose value is the value of this Big plus the value of Big y.
 */
P.plus = P.add = function (y) {
  var e, k, t,
    x = this,
    Big = x.constructor;

  y = new Big(y);

  // Signs differ?
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }

  var xe = x.e,
    xc = x.c,
    ye = y.e,
    yc = y.c;

  // Either zero?
  if (!xc[0] || !yc[0]) {
    if (!yc[0]) {
      if (xc[0]) {
        y = new Big(x);
      } else {
        y.s = x.s;
      }
    }
    return y;
  }

  xc = xc.slice();

  // Prepend zeros to equalise exponents.
  // Note: reverse faster than unshifts.
  if (e = xe - ye) {
    if (e > 0) {
      ye = xe;
      t = yc;
    } else {
      e = -e;
      t = xc;
    }

    t.reverse();
    for (; e--;) t.push(0);
    t.reverse();
  }

  // Point xc to the longer array.
  if (xc.length - yc.length < 0) {
    t = yc;
    yc = xc;
    xc = t;
  }

  e = yc.length;

  // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.
  for (k = 0; e; xc[e] %= 10) k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;

  // No need to check for zero, as +x + +y != 0 && -x + -y != 0

  if (k) {
    xc.unshift(k);
    ++ye;
  }

  // Remove trailing zeros.
  for (e = xc.length; xc[--e] === 0;) xc.pop();

  y.c = xc;
  y.e = ye;

  return y;
};


/*
 * Return a Big whose value is the value of this Big raised to the power n.
 * If n is negative, round to a maximum of Big.DP decimal places using rounding
 * mode Big.RM.
 *
 * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.
 */
P.pow = function (n) {
  var x = this,
    one = new x.constructor('1'),
    y = one,
    isneg = n < 0;

  if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {
    throw Error(INVALID + 'exponent');
  }

  if (isneg) n = -n;

  for (;;) {
    if (n & 1) y = y.times(x);
    n >>= 1;
    if (!n) break;
    x = x.times(x);
  }

  return isneg ? one.div(y) : y;
};


/*
 * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd
 * significant digits using rounding mode rm, or Big.RM if rm is not specified.
 *
 * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.prec = function (sd, rm) {
  if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
    throw Error(INVALID + 'precision');
  }
  return round(new this.constructor(this), sd, rm);
};


/*
 * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places
 * using rounding mode rm, or Big.RM if rm is not specified.
 * If dp is negative, round to an integer which is a multiple of 10**-dp.
 * If dp is not specified, round to 0 decimal places.
 *
 * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.round = function (dp, rm) {
  if (dp === UNDEFINED) dp = 0;
  else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }
  return round(new this.constructor(this), dp + this.e + 1, rm);
};


/*
 * Return a new Big whose value is the square root of the value of this Big, rounded, if
 * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
P.sqrt = function () {
  var r, c, t,
    x = this,
    Big = x.constructor,
    s = x.s,
    e = x.e,
    half = new Big('0.5');

  // Zero?
  if (!x.c[0]) return new Big(x);

  // Negative?
  if (s < 0) {
    throw Error(NAME + 'No square root');
  }

  // Estimate.
  s = Math.sqrt(x + '');

  // Math.sqrt underflow/overflow?
  // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.
  if (s === 0 || s === 1 / 0) {
    c = x.c.join('');
    if (!(c.length + e & 1)) c += '0';
    s = Math.sqrt(c);
    e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
    r = new Big((s == 1 / 0 ? '5e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);
  } else {
    r = new Big(s + '');
  }

  e = r.e + (Big.DP += 4);

  // Newton-Raphson iteration.
  do {
    t = r;
    r = half.times(t.plus(x.div(t)));
  } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));

  return round(r, (Big.DP -= 4) + r.e + 1, Big.RM);
};


/*
 * Return a new Big whose value is the value of this Big times the value of Big y.
 */
P.times = P.mul = function (y) {
  var c,
    x = this,
    Big = x.constructor,
    xc = x.c,
    yc = (y = new Big(y)).c,
    a = xc.length,
    b = yc.length,
    i = x.e,
    j = y.e;

  // Determine sign of result.
  y.s = x.s == y.s ? 1 : -1;

  // Return signed 0 if either 0.
  if (!xc[0] || !yc[0]) {
    y.c = [y.e = 0];
    return y;
  }

  // Initialise exponent of result as x.e + y.e.
  y.e = i + j;

  // If array xc has fewer digits than yc, swap xc and yc, and lengths.
  if (a < b) {
    c = xc;
    xc = yc;
    yc = c;
    j = a;
    a = b;
    b = j;
  }

  // Initialise coefficient array of result with zeros.
  for (c = new Array(j = a + b); j--;) c[j] = 0;

  // Multiply.

  // i is initially xc.length.
  for (i = b; i--;) {
    b = 0;

    // a is yc.length.
    for (j = a + i; j > i;) {

      // Current sum of products at this digit position, plus carry.
      b = c[j] + yc[i] * xc[j - i - 1] + b;
      c[j--] = b % 10;

      // carry
      b = b / 10 | 0;
    }

    c[j] = b;
  }

  // Increment result exponent if there is a final carry, otherwise remove leading zero.
  if (b) ++y.e;
  else c.shift();

  // Remove trailing zeros.
  for (i = c.length; !c[--i];) c.pop();
  y.c = c;

  return y;
};


/*
 * Return a string representing the value of this Big in exponential notation rounded to dp fixed
 * decimal places using rounding mode rm, or Big.RM if rm is not specified.
 *
 * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.toExponential = function (dp, rm) {
  var x = this,
    n = x.c[0];

  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x = round(new x.constructor(x), ++dp, rm);
    for (; x.c.length < dp;) x.c.push(0);
  }

  return stringify(x, true, !!n);
};


/*
 * Return a string representing the value of this Big in normal notation rounded to dp fixed
 * decimal places using rounding mode rm, or Big.RM if rm is not specified.
 *
 * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 *
 * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
 * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
 */
P.toFixed = function (dp, rm) {
  var x = this,
    n = x.c[0];

  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x = round(new x.constructor(x), dp + x.e + 1, rm);

    // x.e may have changed if the value is rounded up.
    for (dp = dp + x.e + 1; x.c.length < dp;) x.c.push(0);
  }

  return stringify(x, false, !!n);
};


/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Omit the sign for negative zero.
 */
P[Symbol.for('nodejs.util.inspect.custom')] = P.toJSON = P.toString = function () {
  var x = this,
    Big = x.constructor;
  return stringify(x, x.e <= Big.NE || x.e >= Big.PE, !!x.c[0]);
};


/*
 * Return the value of this Big as a primitve number.
 */
P.toNumber = function () {
  var n = Number(stringify(this, true, true));
  if (this.constructor.strict === true && !this.eq(n.toString())) {
    throw Error(NAME + 'Imprecise conversion');
  }
  return n;
};


/*
 * Return a string representing the value of this Big rounded to sd significant digits using
 * rounding mode rm, or Big.RM if rm is not specified.
 * Use exponential notation if sd is less than the number of digits necessary to represent
 * the integer part of the value in normal notation.
 *
 * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.toPrecision = function (sd, rm) {
  var x = this,
    Big = x.constructor,
    n = x.c[0];

  if (sd !== UNDEFINED) {
    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
      throw Error(INVALID + 'precision');
    }
    x = round(new Big(x), sd, rm);
    for (; x.c.length < sd;) x.c.push(0);
  }

  return stringify(x, sd <= x.e || x.e <= Big.NE || x.e >= Big.PE, !!n);
};


/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Include the sign for negative zero.
 */
P.valueOf = function () {
  var x = this,
    Big = x.constructor;
  if (Big.strict === true) {
    throw Error(NAME + 'valueOf disallowed');
  }
  return stringify(x, x.e <= Big.NE || x.e >= Big.PE, true);
};


// Export


var Big = _Big_();

const calculatePrettyBalance = (value, decimals = 18, roundOff = true, precision = 0) => {
    const bigDecimalValue = new Big(value.toString());
    const bigDecimalExpo = new Big(Math.pow(10, decimals).toString());
    const calculated = bigDecimalValue.div(bigDecimalExpo);
    if (decimals === 0 || !roundOff) {
        return calculated.toString();
    }
    const decimalFixed = precision || (calculated.lt(100) ? 6 : 2);
    return calculated.toFixed(decimalFixed);
};

const LESS_THAN_ZERO = "0.01";
const ZERO = "0.00";
const currencyMap = {
    USD: "$",
    CAD: "CA$",
    EUR: "",
    SGD: "S$",
    INR: "",
    JPY: "",
    VND: "",
    CNY: "CN",
    KRW: "",
    RUB: "",
    TRY: "",
    NGN: "",
    ARS: "ARS",
    AUD: "A$",
    CHF: "CHF",
    GBP: "",
};
const prettifyCurrency = (value, decimals = 2, currency = "USD", ignoreSmallValue = false, ignoreMinus = true, ignoreZero = false) => {
    let numValue = Number(value);
    let minus = "";
    let currencySuffix = "";
    if (!ignoreMinus && numValue < 0) {
        numValue = Math.abs(numValue);
        minus = "-";
    }
    const currencySymbol = currencyMap[currency] ?? "$";
    if (numValue === 0 || isNaN(numValue)) {
        return ignoreZero
            ? `<${currencySymbol}${LESS_THAN_ZERO}`
            : `${currencySymbol}${ZERO}`;
    }
    if (numValue < 0.01 && ignoreSmallValue) {
        return `<${currencySymbol}${LESS_THAN_ZERO}`;
    }
    if (numValue > 999999999) {
        numValue /= 1000000000;
        currencySuffix = "B";
    }
    else if (numValue > 999999) {
        numValue /= 1000000;
        currencySuffix = "M";
    }
    const factor = Math.pow(10, decimals);
    numValue = Math.floor(numValue * factor) / factor;
    const formatter = new Intl.NumberFormat("en-US", {
        style: "currency",
        currency: currency,
        maximumFractionDigits: decimals,
        currencyDisplay: "symbol",
    });
    const formattedValue = formatter
        .format(numValue)
        .replace(new RegExp(`${currency}\\s?`), currencySymbol);
    return minus + formattedValue + currencySuffix;
};

var ChainName;
(function (ChainName) {
    ChainName["ETH_MAINNET"] = "eth-mainnet";
    ChainName["ETH_GOERLI"] = "eth-goerli";
    ChainName["ETH_SEPOLIA"] = "eth-sepolia";
    ChainName["ETH_HOLESKY"] = "eth-holesky";
    ChainName["MATIC_MAINNET"] = "matic-mainnet";
    ChainName["MATIC_MUMBAI"] = "matic-mumbai";
    ChainName["AVALANCHE_MAINNET"] = "avalanche-mainnet";
    ChainName["AVALANCHE_TESTNET"] = "avalanche-testnet";
    ChainName["BSC_MAINNET"] = "bsc-mainnet";
    ChainName["BSC_TESTNET"] = "bsc-testnet";
    ChainName["MOONBEAM_MAINNET"] = "moonbeam-mainnet";
    ChainName["MOONBEAM_MOONBASE_ALPHA"] = "moonbeam-moonbase-alpha";
    ChainName["MOONBEAM_MOONRIVER"] = "moonbeam-moonriver";
    ChainName["RSK_MAINNET"] = "rsk-mainnet";
    ChainName["RSK_TESTNET"] = "rsk-testnet";
    ChainName["ARBITRUM_MAINNET"] = "arbitrum-mainnet";
    ChainName["ARBITRUM_NOVA_MAINNET"] = "arbitrum-nova-mainnet";
    ChainName["ARBITRUM_SEPOLIA"] = "arbitrum-sepolia";
    ChainName["FANTOM_MAINNET"] = "fantom-mainnet";
    ChainName["FANTOM_TESTNET"] = "fantom-testnet";
    ChainName["PALM_MAINNET"] = "palm-mainnet";
    ChainName["PALM_TESTNET"] = "palm-testnet";
    ChainName["BTC_MAINNET"] = "btc-mainnet";
    ChainName["SOLANA_MAINNET"] = "solana-mainnet";
    ChainName["AXIE_MAINNET"] = "axie-mainnet";
    ChainName["OPTIMISM_MAINNET"] = "optimism-mainnet";
    ChainName["OPTIMISM_SEPOLIA"] = "optimism-sepolia";
    ChainName["EVMOS_MAINNET"] = "evmos-mainnet";
    ChainName["EVMOS_TESTNET"] = "evmos-testnet";
    ChainName["HARMONY_MAINNET"] = "harmony-mainnet";
    ChainName["HARMONY_TESTNET"] = "harmony-testnet";
    ChainName["CRONOS_MAINNET"] = "cronos-mainnet";
    ChainName["CRONOS_TESTNET"] = "cronos-testnet";
    ChainName["CRONOS_ZKEVM_TESTNET"] = "cronos-zkevm-testnet";
    ChainName["AURORA_MAINNET"] = "aurora-mainnet";
    ChainName["AURORA_TESTNET"] = "aurora-testnet";
    ChainName["EMERALD_PARATIME_MAINNET"] = "emerald-paratime-mainnet";
    ChainName["DEFI_KINGDOMS_MAINNET"] = "defi-kingdoms-mainnet";
    ChainName["DEFI_KINGDOMS_TESTNET"] = "defi-kingdoms-testnet";
    ChainName["BOBA_MAINNET"] = "boba-mainnet";
    ChainName["BOBA_BNB_MAINNET"] = "boba-bnb-mainnet";
    ChainName["BOBA_BNB_TESTNET"] = "boba-bnb-testnet";
    ChainName["SCROLL_SEPOLIA_TESTNET"] = "scroll-sepolia-testnet";
    ChainName["METIS_MAINNET"] = "metis-mainnet";
    ChainName["METIS_STARDUST"] = "metis-stardust";
    ChainName["AVALANCHE_DEXALOT_MAINNET"] = "avalanche-dexalot-mainnet";
    ChainName["AVALANCHE_DEXALOT_TESTNET"] = "avalanche-dexalot-testnet";
    ChainName["AVALANCHE_SHRAPNEL_MAINNET"] = "avalanche-shrapnel-mainnet";
    ChainName["AVALANCHE_NUMBERS"] = "avalanche-numbers";
    ChainName["AVALANCHE_DOS"] = "avalanche-dos";
    ChainName["AVALANCHE_XPLUS"] = "avalanche-xplus";
    ChainName["AVALANCHE_XANACHAIN"] = "avalanche-xanachain";
    ChainName["AVALANCHE_STEP_NETWORK"] = "avalanche-step-network";
    ChainName["AVALANCHE_SHRAPNEL_TESTNET"] = "avalanche-shrapnel-testnet";
    ChainName["AVALANCHE_BEAM_TESTNET"] = "avalanche-beam-testnet";
    ChainName["AVALANCHE_BLITZ_TESTNET"] = "avalanche-blitz-testnet";
    ChainName["AVALANCHE_MINTARA_TESTNET"] = "avalanche-mintara-testnet";
    ChainName["AVALANCHE_GREEN_DOT_TESTNET"] = "avalanche-green-dot-testnet";
    ChainName["AVALANCHE_PULSAR_TESTNET"] = "avalanche-pulsar-testnet";
    ChainName["AVALANCHE_UPTN"] = "avalanche-uptn";
    ChainName["AVALANCHE_AVACLOUD_TESTNET"] = "avalanche-avacloud-testnet";
    ChainName["AVALANCHE_BEAM_MAINNET"] = "avalanche-beam-mainnet";
    ChainName["AVALANCHE_BULLETIN_TESTNET"] = "avalanche-bulletin-testnet";
    ChainName["AVALANCHE_CONDUIT_TESTNET"] = "avalanche-conduit-testnet";
    ChainName["AVALANCHE_HERO_TESTNET"] = "avalanche-hero-testnet";
    ChainName["AVALANCHE_HUBBLE_EXCHANGE_TESTNET"] = "avalanche-hubble-exchange-testnet";
    ChainName["AVALANCHE_KIWI_TESTNET"] = "avalanche-kiwi-testnet";
    ChainName["AVALANCHE_MIHO_TESTNET"] = "avalanche-miho-testnet";
    ChainName["AVALANCHE_MONDRIAN_TESTNET"] = "avalanche-mondrian-testnet";
    ChainName["AVALANCHE_NMAC_TESTNET"] = "avalanche-nmac-testnet";
    ChainName["AVALANCHE_ORDERLY_TESTNET"] = "avalanche-orderly-testnet";
    ChainName["AVALANCHE_THIRDWEB_TESTNET"] = "avalanche-thirdweb-testnet";
    ChainName["AVALANCHE_WAGMI_TESTNET"] = "avalanche-wagmi-testnet";
    ChainName["AVALANCHE_PLAYA3ULL_TESTNET"] = "avalanche-playa3ull-testnet";
    ChainName["AVALANCHE_MIRAI_TESTNET"] = "avalanche-mirai-testnet";
    ChainName["AVALANCHE_AMPLIFY_TESTNET"] = "avalanche-amplify-testnet";
    ChainName["AVALANCHE_LT0_TESTNET"] = "avalanche-lt0-testnet";
    ChainName["AVALANCHE_LT5_TESTNET"] = "avalanche-lt5-testnet";
    ChainName["AVALANCHE_HUBBLE_EXCHANGE_MAINNET"] = "avalanche-hubble-exchange-mainnet";
    ChainName["METER_MAINNET"] = "meter-mainnet";
    ChainName["METER_TESTNET"] = "meter-testnet";
    ChainName["MILKOMEDA_A1_MAINNET"] = "milkomeda-a1-mainnet";
    ChainName["MILKOMEDA_C1_MAINNET"] = "milkomeda-c1-mainnet";
    ChainName["MILKOMEDA_C1_DEVNET"] = "milkomeda-c1-devnet";
    ChainName["CANTO_MAINNET"] = "canto-mainnet";
    ChainName["FLARENETWORKS_FLARE_MAINNET"] = "flarenetworks-flare-mainnet";
    ChainName["FLARENETWORKS_FLARE_TESTNET"] = "flarenetworks-flare-testnet";
    ChainName["FLARENETWORKS_CANARY_MAINNET"] = "flarenetworks-canary-mainnet";
    ChainName["FLARENETWORKS_CANARY_TESTNET"] = "flarenetworks-canary-testnet";
    ChainName["KCC_MAINNET"] = "kcc-mainnet";
    ChainName["KCC_TESTNET"] = "kcc-testnet";
    ChainName["LINEA_MAINNET"] = "linea-mainnet";
    ChainName["POLYGON_ZKEVM_MAINNET"] = "polygon-zkevm-mainnet";
    ChainName["LINEA_SEPOLIA_TESTNET"] = "linea-sepolia-testnet";
    ChainName["LINEA_GOERLI_TESTNET"] = "linea-goerli-testnet";
    ChainName["POLYGON_ZKEVM_TESTNET"] = "polygon-zkevm-testnet";
    ChainName["POLYGON_AMOY_TESTNET"] = "polygon-amoy-testnet";
    ChainName["MANTLE_MAINNET"] = "mantle-mainnet";
    ChainName["MANTLE_SEPOLIA_TESTNET"] = "mantle-sepolia-testnet";
    ChainName["POLYGON_ZKEVM_CARDONA_TESTNET"] = "polygon-zkevm-cardona-testnet";
    ChainName["BASE_MAINNET"] = "base-mainnet";
    ChainName["BASE_TESTNET"] = "base-testnet";
    ChainName["BASE_SEPOLIA_TESTNET"] = "base-sepolia-testnet";
    ChainName["OASYS_MAINNET"] = "oasys-mainnet";
    ChainName["OASYS_TESTNET"] = "oasys-testnet";
    ChainName["SX_MAINNET"] = "sx-mainnet";
    ChainName["LUMOZ_PUBLIC_ZKSYNC_V2"] = "lumoz-public-zksync-v2";
    ChainName["LUMOZ_STARK_SPORT"] = "lumoz-stark-sport";
    ChainName["OASIS_SAPPHIRE_MAINNET"] = "oasis-sapphire-mainnet";
    ChainName["OASIS_SAPPHIRE_TESTNET"] = "oasis-sapphire-testnet";
    ChainName["SYNDR_TESTNET"] = "syndr-testnet";
    ChainName["XAI_MAINNET"] = "xai-mainnet";
    ChainName["CELO_MAINNET"] = "celo-mainnet";
    ChainName["X1_MAINNET"] = "x1-mainnet";
    ChainName["CROSSFI_EVM_TESTNET"] = "crossfi-evm-testnet";
    ChainName["HORIZEN_EON_MAINNET"] = "horizen-eon-mainnet";
    ChainName["HORIZEN_GOBI_TESTNET"] = "horizen-gobi-testnet";
    ChainName["FRAXTAL_MAINNET"] = "fraxtal-mainnet";
    ChainName["APECHAIN_TESTNET"] = "apechain-testnet";
    ChainName["LISK_MAINNET"] = "lisk-mainnet";
    ChainName["REDSTONE_MAINNET"] = "redstone-mainnet";
    ChainName["SEI_MAINNET"] = "sei-mainnet";
    ChainName["AVALANCHE_MELD_TESTNET"] = "avalanche-meld-testnet";
    ChainName["AVALANCHE_MELD_MAINNET"] = "avalanche-meld-mainnet";
    ChainName["GUNZILLA_TESTNET"] = "gunzilla-testnet";
    ChainName["ULTRON_MAINNET"] = "ultron-mainnet";
    ChainName["ULTRON_TESTNET"] = "ultron-testnet";
    ChainName["ZORA_MAINNET"] = "zora-mainnet";
    ChainName["ZORA_SEPOLIA_TESTNET"] = "zora-sepolia-testnet";
    ChainName["LISK_SEPOLIA_TESTNET"] = "lisk-sepolia-testnet";
    ChainName["OPSIDE_READON_CONTENT_TESTNET"] = "opside-readon-content-testnet";
    ChainName["ZKSYNC_MAINNET"] = "zksync-mainnet";
    ChainName["ZKSYNC_SEPOLIA_TESTNET"] = "zksync-sepolia-testnet";
    ChainName["BNB_ANTIMATTER_TESTNET"] = "bnb-antimatter-testnet";
    ChainName["BNB_META_APES_MAINNET"] = "bnb-meta-apes-mainnet";
    ChainName["BNB_FNCY_MAINNET"] = "bnb-fncy-mainnet";
    ChainName["BNB_OPBNB_TESTNET"] = "bnb-opbnb-testnet";
    ChainName["BNB_FNCY_TESTNET"] = "bnb-fncy-testnet";
    ChainName["BNB_OPBNB_MAINNET"] = "bnb-opbnb-mainnet";
    ChainName["ZETACHAIN_TESTNET"] = "zetachain-testnet";
    ChainName["ZETACHAIN_MAINNET"] = "zetachain-mainnet";
    ChainName["MODE_TESTNET"] = "mode-testnet";
    ChainName["MODE_MAINNET"] = "mode-mainnet";
    ChainName["KINTO_TESTNET"] = "kinto-testnet";
    ChainName["LOOT_MAINNET"] = "loot-mainnet";
    ChainName["PGN_MAINNET"] = "pgn-mainnet";
    ChainName["PGN_TESTNET"] = "pgn-testnet";
    ChainName["MANTA_SEPOLIA_TESTNET"] = "manta-sepolia-testnet";
    ChainName["ROLLUX_MAINNET"] = "rollux-mainnet";
    ChainName["ROLLUX_TESTNET"] = "rollux-testnet";
    ChainName["GNOSIS_MAINNET"] = "gnosis-mainnet";
    ChainName["GNOSIS_TESTNET"] = "gnosis-testnet";
    ChainName["TELOS_MAINNET"] = "telos-mainnet";
    ChainName["TELOS_TESTNET"] = "telos-testnet";
    ChainName["TOMOCHAIN_MAINNET"] = "tomochain-mainnet";
    ChainName["TOMOCHAIN_TESTNET"] = "tomochain-testnet";
    ChainName["TAIKO_MAINNET"] = "taiko-mainnet";
    ChainName["TAIKO_HEKLA_TESTNET"] = "taiko-hekla-testnet";
    ChainName["MERLIN_MAINNET"] = "merlin-mainnet";
    ChainName["MERLIN_TESTNET"] = "merlin-testnet";
    ChainName["BLAST_MAINNET"] = "blast-mainnet";
    ChainName["MOVEMENT_MEVM_TESTNET"] = "movement-mevm-testnet";
    ChainName["SCROLL_MAINNET"] = "scroll-mainnet";
    ChainName["COVALENT_INTERNAL_NETWORK_V1"] = "covalent-internal-network-v1";
})(ChainName || (ChainName = {}));
var ChainID;
(function (ChainID) {
    ChainID[ChainID["ETH_MAINNET"] = 1] = "ETH_MAINNET";
    ChainID[ChainID["ETH_GOERLI"] = 5] = "ETH_GOERLI";
    ChainID[ChainID["ETH_SEPOLIA"] = 11155111] = "ETH_SEPOLIA";
    ChainID[ChainID["ETH_HOLESKY"] = 17000] = "ETH_HOLESKY";
    ChainID[ChainID["MATIC_MAINNET"] = 137] = "MATIC_MAINNET";
    ChainID[ChainID["MATIC_MUMBAI"] = 80001] = "MATIC_MUMBAI";
    ChainID[ChainID["AVALANCHE_MAINNET"] = 43114] = "AVALANCHE_MAINNET";
    ChainID[ChainID["AVALANCHE_TESTNET"] = 43113] = "AVALANCHE_TESTNET";
    ChainID[ChainID["BSC_MAINNET"] = 56] = "BSC_MAINNET";
    ChainID[ChainID["BSC_TESTNET"] = 97] = "BSC_TESTNET";
    ChainID[ChainID["MOONBEAM_MAINNET"] = 1284] = "MOONBEAM_MAINNET";
    ChainID[ChainID["MOONBEAM_MOONBASE_ALPHA"] = 1287] = "MOONBEAM_MOONBASE_ALPHA";
    ChainID[ChainID["MOONBEAM_MOONRIVER"] = 1285] = "MOONBEAM_MOONRIVER";
    ChainID[ChainID["RSK_MAINNET"] = 30] = "RSK_MAINNET";
    ChainID[ChainID["RSK_TESTNET"] = 31] = "RSK_TESTNET";
    ChainID[ChainID["ARBITRUM_MAINNET"] = 42161] = "ARBITRUM_MAINNET";
    ChainID[ChainID["ARBITRUM_NOVA_MAINNET"] = 42170] = "ARBITRUM_NOVA_MAINNET";
    ChainID[ChainID["ARBITRUM_SEPOLIA"] = 421614] = "ARBITRUM_SEPOLIA";
    ChainID[ChainID["FANTOM_MAINNET"] = 250] = "FANTOM_MAINNET";
    ChainID[ChainID["FANTOM_TESTNET"] = 4002] = "FANTOM_TESTNET";
    ChainID[ChainID["PALM_MAINNET"] = 11297108109] = "PALM_MAINNET";
    ChainID[ChainID["PALM_TESTNET"] = 11297108099] = "PALM_TESTNET";
    ChainID[ChainID["BTC_MAINNET"] = 20090103] = "BTC_MAINNET";
    ChainID[ChainID["SOLANA_MAINNET"] = 1399811149] = "SOLANA_MAINNET";
    ChainID[ChainID["AXIE_MAINNET"] = 2020] = "AXIE_MAINNET";
    ChainID[ChainID["OPTIMISM_MAINNET"] = 10] = "OPTIMISM_MAINNET";
    ChainID[ChainID["OPTIMISM_SEPOLIA"] = 11155420] = "OPTIMISM_SEPOLIA";
    ChainID[ChainID["EVMOS_MAINNET"] = 9001] = "EVMOS_MAINNET";
    ChainID[ChainID["EVMOS_TESTNET"] = 9000] = "EVMOS_TESTNET";
    ChainID[ChainID["HARMONY_MAINNET"] = 1666600000] = "HARMONY_MAINNET";
    ChainID[ChainID["HARMONY_TESTNET"] = 1666700000] = "HARMONY_TESTNET";
    ChainID[ChainID["CRONOS_MAINNET"] = 25] = "CRONOS_MAINNET";
    ChainID[ChainID["CRONOS_TESTNET"] = 338] = "CRONOS_TESTNET";
    ChainID[ChainID["CRONOS_ZKEVM_TESTNET"] = 282] = "CRONOS_ZKEVM_TESTNET";
    ChainID[ChainID["AURORA_MAINNET"] = 1313161554] = "AURORA_MAINNET";
    ChainID[ChainID["AURORA_TESTNET"] = 1313161555] = "AURORA_TESTNET";
    ChainID[ChainID["EMERALD_PARATIME_MAINNET"] = 42262] = "EMERALD_PARATIME_MAINNET";
    ChainID[ChainID["DEFI_KINGDOMS_MAINNET"] = 53935] = "DEFI_KINGDOMS_MAINNET";
    ChainID[ChainID["DEFI_KINGDOMS_TESTNET"] = 335] = "DEFI_KINGDOMS_TESTNET";
    ChainID[ChainID["BOBA_MAINNET"] = 288] = "BOBA_MAINNET";
    ChainID[ChainID["BOBA_BNB_MAINNET"] = 56288] = "BOBA_BNB_MAINNET";
    ChainID[ChainID["BOBA_BNB_TESTNET"] = 9728] = "BOBA_BNB_TESTNET";
    ChainID[ChainID["SCROLL_SEPOLIA_TESTNET"] = 534351] = "SCROLL_SEPOLIA_TESTNET";
    ChainID[ChainID["METIS_MAINNET"] = 1088] = "METIS_MAINNET";
    ChainID[ChainID["METIS_STARDUST"] = 588] = "METIS_STARDUST";
    ChainID[ChainID["AVALANCHE_DEXALOT_MAINNET"] = 432204] = "AVALANCHE_DEXALOT_MAINNET";
    ChainID[ChainID["AVALANCHE_DEXALOT_TESTNET"] = 432201] = "AVALANCHE_DEXALOT_TESTNET";
    ChainID[ChainID["AVALANCHE_SHRAPNEL_MAINNET"] = 2044] = "AVALANCHE_SHRAPNEL_MAINNET";
    ChainID[ChainID["AVALANCHE_NUMBERS"] = 10507] = "AVALANCHE_NUMBERS";
    ChainID[ChainID["AVALANCHE_DOS"] = 7979] = "AVALANCHE_DOS";
    ChainID[ChainID["AVALANCHE_XPLUS"] = 1228] = "AVALANCHE_XPLUS";
    ChainID[ChainID["AVALANCHE_XANACHAIN"] = 8888] = "AVALANCHE_XANACHAIN";
    ChainID[ChainID["AVALANCHE_STEP_NETWORK"] = 1234] = "AVALANCHE_STEP_NETWORK";
    ChainID[ChainID["AVALANCHE_SHRAPNEL_TESTNET"] = 2038] = "AVALANCHE_SHRAPNEL_TESTNET";
    ChainID[ChainID["AVALANCHE_BEAM_TESTNET"] = 13337] = "AVALANCHE_BEAM_TESTNET";
    ChainID[ChainID["AVALANCHE_BLITZ_TESTNET"] = 1343] = "AVALANCHE_BLITZ_TESTNET";
    ChainID[ChainID["AVALANCHE_MINTARA_TESTNET"] = 1079] = "AVALANCHE_MINTARA_TESTNET";
    ChainID[ChainID["AVALANCHE_GREEN_DOT_TESTNET"] = 6765897100] = "AVALANCHE_GREEN_DOT_TESTNET";
    ChainID[ChainID["AVALANCHE_PULSAR_TESTNET"] = 431234] = "AVALANCHE_PULSAR_TESTNET";
    ChainID[ChainID["AVALANCHE_UPTN"] = 6119] = "AVALANCHE_UPTN";
    ChainID[ChainID["AVALANCHE_AVACLOUD_TESTNET"] = 152703] = "AVALANCHE_AVACLOUD_TESTNET";
    ChainID[ChainID["AVALANCHE_BEAM_MAINNET"] = 4337] = "AVALANCHE_BEAM_MAINNET";
    ChainID[ChainID["AVALANCHE_BULLETIN_TESTNET"] = 78431] = "AVALANCHE_BULLETIN_TESTNET";
    ChainID[ChainID["AVALANCHE_CONDUIT_TESTNET"] = 78432] = "AVALANCHE_CONDUIT_TESTNET";
    ChainID[ChainID["AVALANCHE_HERO_TESTNET"] = 17772] = "AVALANCHE_HERO_TESTNET";
    ChainID[ChainID["AVALANCHE_HUBBLE_EXCHANGE_TESTNET"] = 321123] = "AVALANCHE_HUBBLE_EXCHANGE_TESTNET";
    ChainID[ChainID["AVALANCHE_KIWI_TESTNET"] = 2037] = "AVALANCHE_KIWI_TESTNET";
    ChainID[ChainID["AVALANCHE_MIHO_TESTNET"] = 360163] = "AVALANCHE_MIHO_TESTNET";
    ChainID[ChainID["AVALANCHE_MONDRIAN_TESTNET"] = 179188] = "AVALANCHE_MONDRIAN_TESTNET";
    ChainID[ChainID["AVALANCHE_NMAC_TESTNET"] = 7777] = "AVALANCHE_NMAC_TESTNET";
    ChainID[ChainID["AVALANCHE_ORDERLY_TESTNET"] = 986532] = "AVALANCHE_ORDERLY_TESTNET";
    ChainID[ChainID["AVALANCHE_THIRDWEB_TESTNET"] = 894538] = "AVALANCHE_THIRDWEB_TESTNET";
    ChainID[ChainID["AVALANCHE_WAGMI_TESTNET"] = 11111] = "AVALANCHE_WAGMI_TESTNET";
    ChainID[ChainID["AVALANCHE_PLAYA3ULL_TESTNET"] = 3012] = "AVALANCHE_PLAYA3ULL_TESTNET";
    ChainID[ChainID["AVALANCHE_MIRAI_TESTNET"] = 2195] = "AVALANCHE_MIRAI_TESTNET";
    ChainID[ChainID["AVALANCHE_AMPLIFY_TESTNET"] = 78430] = "AVALANCHE_AMPLIFY_TESTNET";
    ChainID[ChainID["AVALANCHE_LT0_TESTNET"] = 31330] = "AVALANCHE_LT0_TESTNET";
    ChainID[ChainID["AVALANCHE_LT5_TESTNET"] = 31335] = "AVALANCHE_LT5_TESTNET";
    ChainID[ChainID["AVALANCHE_HUBBLE_EXCHANGE_MAINNET"] = 1992] = "AVALANCHE_HUBBLE_EXCHANGE_MAINNET";
    ChainID[ChainID["METER_MAINNET"] = 82] = "METER_MAINNET";
    ChainID[ChainID["METER_TESTNET"] = 83] = "METER_TESTNET";
    ChainID[ChainID["MILKOMEDA_A1_MAINNET"] = 2002] = "MILKOMEDA_A1_MAINNET";
    ChainID[ChainID["MILKOMEDA_C1_MAINNET"] = 2001] = "MILKOMEDA_C1_MAINNET";
    ChainID[ChainID["MILKOMEDA_C1_DEVNET"] = 200101] = "MILKOMEDA_C1_DEVNET";
    ChainID[ChainID["CANTO_MAINNET"] = 7700] = "CANTO_MAINNET";
    ChainID[ChainID["FLARENETWORKS_FLARE_MAINNET"] = 14] = "FLARENETWORKS_FLARE_MAINNET";
    ChainID[ChainID["FLARENETWORKS_FLARE_TESTNET"] = 114] = "FLARENETWORKS_FLARE_TESTNET";
    ChainID[ChainID["FLARENETWORKS_CANARY_MAINNET"] = 19] = "FLARENETWORKS_CANARY_MAINNET";
    ChainID[ChainID["FLARENETWORKS_CANARY_TESTNET"] = 16] = "FLARENETWORKS_CANARY_TESTNET";
    ChainID[ChainID["KCC_MAINNET"] = 321] = "KCC_MAINNET";
    ChainID[ChainID["KCC_TESTNET"] = 322] = "KCC_TESTNET";
    ChainID[ChainID["LINEA_MAINNET"] = 59144] = "LINEA_MAINNET";
    ChainID[ChainID["POLYGON_ZKEVM_MAINNET"] = 1101] = "POLYGON_ZKEVM_MAINNET";
    ChainID[ChainID["LINEA_SEPOLIA_TESTNET"] = 59141] = "LINEA_SEPOLIA_TESTNET";
    ChainID[ChainID["LINEA_GOERLI_TESTNET"] = 59140] = "LINEA_GOERLI_TESTNET";
    ChainID[ChainID["POLYGON_ZKEVM_TESTNET"] = 1422] = "POLYGON_ZKEVM_TESTNET";
    ChainID[ChainID["POLYGON_AMOY_TESTNET"] = 80002] = "POLYGON_AMOY_TESTNET";
    ChainID[ChainID["MANTLE_MAINNET"] = 5000] = "MANTLE_MAINNET";
    ChainID[ChainID["MANTLE_SEPOLIA_TESTNET"] = 5003] = "MANTLE_SEPOLIA_TESTNET";
    ChainID[ChainID["POLYGON_ZKEVM_CARDONA_TESTNET"] = 2442] = "POLYGON_ZKEVM_CARDONA_TESTNET";
    ChainID[ChainID["BASE_MAINNET"] = 8453] = "BASE_MAINNET";
    ChainID[ChainID["BASE_TESTNET"] = 84531] = "BASE_TESTNET";
    ChainID[ChainID["BASE_SEPOLIA_TESTNET"] = 84532] = "BASE_SEPOLIA_TESTNET";
    ChainID[ChainID["OASYS_MAINNET"] = 248] = "OASYS_MAINNET";
    ChainID[ChainID["OASYS_TESTNET"] = 9372] = "OASYS_TESTNET";
    ChainID[ChainID["SX_MAINNET"] = 416] = "SX_MAINNET";
    ChainID[ChainID["LUMOZ_PUBLIC_ZKSYNC_V2"] = 12027] = "LUMOZ_PUBLIC_ZKSYNC_V2";
    ChainID[ChainID["LUMOZ_STARK_SPORT"] = 12029] = "LUMOZ_STARK_SPORT";
    ChainID[ChainID["OASIS_SAPPHIRE_MAINNET"] = 23294] = "OASIS_SAPPHIRE_MAINNET";
    ChainID[ChainID["OASIS_SAPPHIRE_TESTNET"] = 23295] = "OASIS_SAPPHIRE_TESTNET";
    ChainID[ChainID["SYNDR_TESTNET"] = 412346] = "SYNDR_TESTNET";
    ChainID[ChainID["XAI_MAINNET"] = 660279] = "XAI_MAINNET";
    ChainID[ChainID["CELO_MAINNET"] = 42220] = "CELO_MAINNET";
    ChainID[ChainID["X1_MAINNET"] = 196] = "X1_MAINNET";
    ChainID[ChainID["CROSSFI_EVM_TESTNET"] = 8545] = "CROSSFI_EVM_TESTNET";
    ChainID[ChainID["HORIZEN_EON_MAINNET"] = 7332] = "HORIZEN_EON_MAINNET";
    ChainID[ChainID["HORIZEN_GOBI_TESTNET"] = 1663] = "HORIZEN_GOBI_TESTNET";
    ChainID[ChainID["FRAXTAL_MAINNET"] = 252] = "FRAXTAL_MAINNET";
    ChainID[ChainID["APECHAIN_TESTNET"] = 1798] = "APECHAIN_TESTNET";
    ChainID[ChainID["LISK_MAINNET"] = 1135] = "LISK_MAINNET";
    ChainID[ChainID["REDSTONE_MAINNET"] = 690] = "REDSTONE_MAINNET";
    ChainID[ChainID["SEI_MAINNET"] = 1329] = "SEI_MAINNET";
    ChainID[ChainID["AVALANCHE_MELD_TESTNET"] = 222000222] = "AVALANCHE_MELD_TESTNET";
    ChainID[ChainID["AVALANCHE_MELD_MAINNET"] = 333000333] = "AVALANCHE_MELD_MAINNET";
    ChainID[ChainID["GUNZILLA_TESTNET"] = 49321] = "GUNZILLA_TESTNET";
    ChainID[ChainID["ULTRON_MAINNET"] = 1231] = "ULTRON_MAINNET";
    ChainID[ChainID["ULTRON_TESTNET"] = 1230] = "ULTRON_TESTNET";
    ChainID[ChainID["ZORA_MAINNET"] = 7777777] = "ZORA_MAINNET";
    ChainID[ChainID["ZORA_SEPOLIA_TESTNET"] = 999999999] = "ZORA_SEPOLIA_TESTNET";
    ChainID[ChainID["LISK_SEPOLIA_TESTNET"] = 4202] = "LISK_SEPOLIA_TESTNET";
    ChainID[ChainID["OPSIDE_READON_CONTENT_TESTNET"] = 12015] = "OPSIDE_READON_CONTENT_TESTNET";
    ChainID[ChainID["ZKSYNC_MAINNET"] = 324] = "ZKSYNC_MAINNET";
    ChainID[ChainID["ZKSYNC_SEPOLIA_TESTNET"] = 300] = "ZKSYNC_SEPOLIA_TESTNET";
    ChainID[ChainID["BNB_ANTIMATTER_TESTNET"] = 20221] = "BNB_ANTIMATTER_TESTNET";
    ChainID[ChainID["BNB_META_APES_MAINNET"] = 16350] = "BNB_META_APES_MAINNET";
    ChainID[ChainID["BNB_FNCY_MAINNET"] = 73] = "BNB_FNCY_MAINNET";
    ChainID[ChainID["BNB_OPBNB_TESTNET"] = 5611] = "BNB_OPBNB_TESTNET";
    ChainID[ChainID["BNB_FNCY_TESTNET"] = 923018] = "BNB_FNCY_TESTNET";
    ChainID[ChainID["BNB_OPBNB_MAINNET"] = 204] = "BNB_OPBNB_MAINNET";
    ChainID[ChainID["ZETACHAIN_TESTNET"] = 7001] = "ZETACHAIN_TESTNET";
    ChainID[ChainID["ZETACHAIN_MAINNET"] = 7000] = "ZETACHAIN_MAINNET";
    ChainID[ChainID["MODE_TESTNET"] = 919] = "MODE_TESTNET";
    ChainID[ChainID["MODE_MAINNET"] = 34443] = "MODE_MAINNET";
    ChainID[ChainID["KINTO_TESTNET"] = 42888] = "KINTO_TESTNET";
    ChainID[ChainID["LOOT_MAINNET"] = 5151706] = "LOOT_MAINNET";
    ChainID[ChainID["PGN_MAINNET"] = 424] = "PGN_MAINNET";
    ChainID[ChainID["PGN_TESTNET"] = 58008] = "PGN_TESTNET";
    ChainID[ChainID["MANTA_SEPOLIA_TESTNET"] = 3441006] = "MANTA_SEPOLIA_TESTNET";
    ChainID[ChainID["ROLLUX_MAINNET"] = 570] = "ROLLUX_MAINNET";
    ChainID[ChainID["ROLLUX_TESTNET"] = 57000] = "ROLLUX_TESTNET";
    ChainID[ChainID["GNOSIS_MAINNET"] = 100] = "GNOSIS_MAINNET";
    ChainID[ChainID["GNOSIS_TESTNET"] = 10200] = "GNOSIS_TESTNET";
    ChainID[ChainID["TELOS_MAINNET"] = 40] = "TELOS_MAINNET";
    ChainID[ChainID["TELOS_TESTNET"] = 41] = "TELOS_TESTNET";
    ChainID[ChainID["TOMOCHAIN_MAINNET"] = 88] = "TOMOCHAIN_MAINNET";
    ChainID[ChainID["TOMOCHAIN_TESTNET"] = 89] = "TOMOCHAIN_TESTNET";
    ChainID[ChainID["TAIKO_MAINNET"] = 167000] = "TAIKO_MAINNET";
    ChainID[ChainID["TAIKO_HEKLA_TESTNET"] = 167009] = "TAIKO_HEKLA_TESTNET";
    ChainID[ChainID["MERLIN_MAINNET"] = 4200] = "MERLIN_MAINNET";
    ChainID[ChainID["MERLIN_TESTNET"] = 686868] = "MERLIN_TESTNET";
    ChainID[ChainID["BLAST_MAINNET"] = 81457] = "BLAST_MAINNET";
    ChainID[ChainID["MOVEMENT_MEVM_TESTNET"] = 336] = "MOVEMENT_MEVM_TESTNET";
    ChainID[ChainID["SCROLL_MAINNET"] = 534352] = "SCROLL_MAINNET";
    ChainID[ChainID["COVALENT_INTERNAL_NETWORK_V1"] = 1131378225] = "COVALENT_INTERNAL_NETWORK_V1";
})(ChainID || (ChainID = {}));

export { ChainID, ChainName, GoldRushClient, bigIntParser, calculatePrettyBalance, isValidApiKey, prettifyCurrency };
//# sourceMappingURL=index.js.map
